---
title: "questionnaires_concise"
author: "Aamir Sohail"
date: "2025-01-17"
output: html_document
---

```{r setup, include=FALSE, message=FALSE, cache=TRUE}
# Install packages only if they are not already installed
required_packages <- c("ggplot2", "tidyverse", "ggpubr", "rstatix", "ez", "lme4", "lmerTest", "car", "emmeans", "MuMIn", "psych", "interactions", "effects", "here", "lm.beta", "effectsize", "parallel")
install_if_missing <- required_packages[!required_packages %in% installed.packages()]
if (length(install_if_missing) > 0) {
  install.packages(install_if_missing, quietly = TRUE)
}

# Load libraries
library(ggplot2)
library(tidyverse)
library(ggpubr)
library(rstatix)
library(ez)
library(lme4)
library(car)
library(readr)
library(lmerTest)
library(emmeans)
library(MuMIn)
library(corrplot)
library(reshape2)
library(psych)
library(interactions)
library(effects)
library(here)
library(conflicted)
library(lm.beta)
library(effectsize)
library(parallel)

conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflicts_prefer(lmerTest::lmer)
conflicts_prefer(effectsize::eta_squared)
```

## Within-trial choice switch probability and bet difference by group consensus and direction

```{r setup, include=FALSE, message=FALSE}
rm(list=ls())

# Source the core pipeline functions
source(here("R", "questionnaire_mixed_models.R"))

################## SPECIFIC PREPROCESSING ###################
preprocess_consensus_data <- function(data, outcome_type, questionnaire_var, group_2_2_in_with = FALSE, params) {
  print(paste("Processing questionnaire:", questionnaire_var))
  print(paste("Initial number of unique participants:", length(unique(data$participant.id_in_session))))
  
  # Get subscales for the current questionnaire
  subscales <- params$subscale_mapping[[questionnaire_var]]
  
  base_data <- data %>%
    mutate(
      consensus_level = case_when(
        player.choice1_with %in% c(0, 1) ~ "4:0",
        player.choice1_with %in% c(0.25, 0.75) ~ "3:1",
        player.choice1_with == 0.5 ~ "2:2"
      ),
      direction = case_when(
        consensus_level == "2:2" ~ if(group_2_2_in_with) "With group" else "Against group",
        player.choice1_with >= 0.5 ~ "With group",
        TRUE ~ "Against group"
      ),
      consensus_level = factor(consensus_level, levels = c("2:2", "3:1", "4:0")),
      direction = factor(direction, levels = c("Against group", "With group"))
    ) %>%
    filter(!(consensus_level == "2:2" & direction == "With group"))

  # Process outcome variable
  outcome_data <- if(outcome_type == "switch") {
    base_data %>%
      group_by(participant.id_in_session, consensus_level, direction, gender) %>%
      summarise(
        outcome_value = mean(player.switch_vs_stay) * 100,
        .groups = 'drop'
      )
  } else {
    base_data %>%
      mutate(bet_difference = player.bet2 - player.bet1) %>%
      group_by(participant.id_in_session, consensus_level, direction, gender) %>%
      summarise(
        outcome_value = mean(bet_difference),
        .groups = 'drop'
      )
  }

  # Join with questionnaire data 
  joined_data <- outcome_data %>%
    left_join(
      base_data %>%
        group_by(participant.id_in_session) %>%
        slice(1) %>%
        select(participant.id_in_session, 
               !!questionnaire_var, 
               age,
               !!!syms(subscales)),
      by = "participant.id_in_session"
    )
  
  # Scale main variables and subscales consistently
  scaled_data <- joined_data %>%
    mutate(
      scale_name = as.numeric(scale(.data[[questionnaire_var]])),
      age = as.numeric(scale(age)),
      gender = factor(gender)
    )

  # Scale subscales if they exist
  if (!is.null(subscales)) {
    for (subscale in subscales) {
      scaled_data[[subscale]] <- as.numeric(scale(scaled_data[[subscale]]))
    }
  }

  return(scaled_data)
}

################## MODEL FORMULAS ###################
consensus_model_formulas <- list(
  m1 = list(
    formula = outcome_value ~ consensus_level + direction + scale_name + 
              age + (1|participant.id_in_session),
    description = "Main effects only"
  ),
  m2 = list(
    formula = outcome_value ~ (consensus_level + direction + scale_name)^2 + 
              age + (1|participant.id_in_session),
    description = "Two-way interactions"
  ),
  m3 = list(
    formula = outcome_value ~ consensus_level * direction * scale_name + 
              age + (1|participant.id_in_session),
    description = "Three-way interaction"
  ),
  m4 = list(
    formula = outcome_value ~ consensus_level * direction * scale_name + 
              age + (1 + consensus_level|participant.id_in_session),
    description = "Three-way with random slope"
  ),
  m5 = list(
    formula = outcome_value ~ consensus_level * direction * scale_name + 
              age + (1 + consensus_level|participant.id_in_session) + (1|gender),
    description = "Full model with gender"
  )
)

# Define parameters for switch analysis
switch_params <- list(
  analysis_type = "choice_consensus",
  preprocessing_fn = function(data, var, params) {
    preprocess_consensus_data(data, "switch", var, group_2_2_in_with = FALSE, params)  # Explicitly set 2:2 to Against group
  },
  model_formulas = consensus_model_formulas,
  questionnaire_vars = c("ssms", "dass", "lsas", "srp_sf", "ami", "aq_10"),
  analysis_name = "Choice Switch by Group Consensus",
  y_label = "Choice switch probability (%)",
  is_percentage = TRUE,
  subscale_mapping = list(
    lsas = c("lsas_p", "lsas_s"),
    dass = c("dass_a", "dass_d", "dass_s"),
    ssms = c("ssms_cd", "ssms_ia"),
    srp_sf = c("srp_sf_ipm", "srp_sf_ca", "srp_sf_els", "srp_sf_ct"),
    ami = c("ami_es", "ami_sm", "ami_ba"),
    aq_10 = NULL
  )
)

# Define parameters for bet analysis
bet_params <- list(
  analysis_type = "choice_consensus",
  preprocessing_fn = function(data, var, params) {
    preprocess_consensus_data(data, "bet", var, group_2_2_in_with = FALSE, params)  # Explicitly set 2:2 to Against group
  },
  model_formulas = consensus_model_formulas,
  questionnaire_vars = c("ssms", "dass", "lsas", "srp_sf", "ami", "aq_10"),
  analysis_name = "Bet Difference by Group Consensus",
  y_label = "Bet difference (Bet 2 - Bet 1)",
  is_percentage = FALSE,
  subscale_mapping = list(
    lsas = c("lsas_p", "lsas_s"),
    dass = c("dass_a", "dass_d", "dass_s"),
    ssms = c("ssms_cd", "ssms_ia"),
    srp_sf = c("srp_sf_ipm", "srp_sf_ca", "srp_sf_els", "srp_sf_ct"),
    ami = c("ami_es", "ami_sm", "ami_ba"),
    aq_10 = NULL
  )
)

################## RUN ANALYSES AND SAVE OUTPUT ###################
# Read data
data <- read_csv(here("data", "preprocessed", "merged_test_data.csv"), 
                 show_col_types = FALSE)

# Define directory structure
questionnaire_dir <- here("output", "behav", "questionnaire")
analysis_dir <- file.path(questionnaire_dir, "ch_switch_and_bet_diff_by_consensus_within_trials")

# Create main output directories for plots and txt
plot_base_dir <- file.path(analysis_dir, "plots")
txt_base_dir <- file.path(analysis_dir, "txt")

# Create txt directory
dir.create(txt_base_dir, recursive = TRUE, showWarnings = FALSE)

# Run switch analysis
switch_results <- run_model_pipeline(
  data = data,
  params = switch_params,
  output_path = file.path(txt_base_dir, "choice_switching_by_group_consensus.txt")
)

# Run bet analysis
bet_results <- run_model_pipeline(
  data = data,
  params = bet_params,
  output_path = file.path(txt_base_dir, "bet_difference_by_group_consensus.txt")
)

# Save plots for both analyses (chunk 1)
save_analysis_plots(switch_results, "choice_switch", analysis_dir)
save_analysis_plots(bet_results, "bet_difference", analysis_dir)
```

## Choice accuracy and bet magnitude as a function of switch difference across trials (Choice 2 - Choice 1), by group consensus and direction

```{r setup, include=FALSE, message=FALSE}
rm(list=ls())

# Source the core pipeline functions
source(here("R", "questionnaire_mixed_models.R"))

################## SPECIFIC PREPROCESSING ###################
preprocess_switch_diff_data <- function(data, outcome_type, questionnaire_var, params) {
  # Get subscales for the current questionnaire
  subscales <- params$subscale_mapping[[questionnaire_var]]
  
  # Create base transformations
  base_data <- data %>%
    filter(!is.na(choice_switch_across_trials)) %>%
    mutate(
      switch_difference = choice_switch_across_trials,  
      trial_type = factor(if_else(choice_switch_across_trials == 0, "Stay", "Switch"), 
                         levels = c("Stay", "Switch")),
      consensus_level = case_when(
        player.choice1_with %in% c(0, 1) ~ "4:0",
        player.choice1_with %in% c(0.25, 0.75) ~ "3:1",
        player.choice1_with == 0.5 ~ "2:2"
      ),
      direction = case_when(
        consensus_level == "2:2" ~ "Against group",
        player.choice1_with >= 0.5 ~ "With group",
        TRUE ~ "Against group"
      ),
      consensus_level = factor(consensus_level, levels = c("2:2", "3:1", "4:0")),
      direction = factor(direction, levels = c("Against group", "With group"))
    ) %>%
    filter(!(consensus_level == "2:2" & direction == "With group"))

  # Process outcome variable based on type
  outcome_data <- if(outcome_type == "accuracy") {
    base_data %>%
      group_by(participant.id_in_session, consensus_level, direction, switch_difference, trial_type, gender) %>%
      summarise(
        outcome_value = mean(player.choice1_accuracy) * 100,
        .groups = 'drop'
      )
  } else {  # bet magnitude
    base_data %>%
      group_by(participant.id_in_session, consensus_level, direction, switch_difference, trial_type, gender) %>%
      summarise(
        outcome_value = mean(player.bet1),
        .groups = 'drop'
      )
  }

  # Join with questionnaire data and scale other variables
  scaled_data <- outcome_data %>%
    left_join(
      base_data %>%
        group_by(participant.id_in_session) %>%
        slice(1) %>%
        select(participant.id_in_session, 
               !!questionnaire_var, 
               age,
               !!!syms(subscales)),
      by = "participant.id_in_session"
    ) %>%
    mutate(
      scale_name = as.numeric(scale(.data[[questionnaire_var]])),
      age = as.numeric(scale(age)),
      gender = factor(gender)
    )

  # Scale subscales if they exist
  if (!is.null(subscales)) {
    for (subscale in subscales) {
      scaled_data[[subscale]] <- as.numeric(scale(scaled_data[[subscale]]))
    }
  }

  return(scaled_data)
}

################## MODEL FORMULAS ###################
switch_diff_model_formulas <- list(
  m1 = list(
    formula = outcome_value ~ consensus_level + direction + switch_difference + scale_name + 
              age + (1|participant.id_in_session),
    description = "Main effects only"
  ),
  m2 = list(
    formula = outcome_value ~ (consensus_level + direction + switch_difference + scale_name)^2 + 
              age + (1|participant.id_in_session),
    description = "Two-way interactions"
  ),
  m3 = list(
    formula = outcome_value ~ consensus_level * direction * switch_difference * scale_name + 
              age + (1|participant.id_in_session),
    description = "Three-way interaction"
  ),
  m4 = list(
    formula = outcome_value ~ consensus_level * direction * switch_difference * scale_name + 
              age + (1 + switch_difference|participant.id_in_session),
    description = "Three-way with random slope for switch difference"
  ),
  m5 = list(
    formula = outcome_value ~ consensus_level * direction * switch_difference * scale_name + 
              age + (1 + switch_difference|participant.id_in_session) + (1|gender),
    description = "Full model with gender"
  )
)

# Define parameters for accuracy analysis
accuracy_params <- list(
  analysis_type = "switch_difference",
  preprocessing_fn = function(data, var, params) {  # Added params parameter
    preprocess_switch_diff_data(data, "accuracy", var, params)  # Pass params through
  },
  model_formulas = switch_diff_model_formulas,
  questionnaire_vars = c("ssms", "dass", "lsas", "srp_sf", "ami", "aq_10"),
  analysis_name = "Choice Accuracy by Switch Difference",
  y_label = "Choice 1 accuracy on t + 1 (%)",
  is_percentage = TRUE,
  subscale_mapping = list(
    lsas = c("lsas_p", "lsas_s"),
    dass = c("dass_a", "dass_d", "dass_s"),
    ssms = c("ssms_cd", "ssms_ia"),
    srp_sf = c("srp_sf_ipm", "srp_sf_ca", "srp_sf_els", "srp_sf_ct"),
    ami = c("ami_es", "ami_sm", "ami_ba"),
    aq_10 = NULL
  )
)

# Define parameters for bet analysis
bet_params <- list(
  analysis_type = "switch_difference",
  preprocessing_fn = function(data, var, params) {  # Added params parameter
    preprocess_switch_diff_data(data, "bet", var, params)  # Pass params through
  },
  model_formulas = switch_diff_model_formulas,
  questionnaire_vars = c("ssms", "dass", "lsas", "srp_sf", "ami", "aq_10"),
  analysis_name = "Bet Magnitude by Switch Difference",
  y_label = "Bet 1 magnitude on t + 1",
  is_percentage = FALSE,
  subscale_mapping = list(
    lsas = c("lsas_p", "lsas_s"),
    dass = c("dass_a", "dass_d", "dass_s"),
    ssms = c("ssms_cd", "ssms_ia"),
    srp_sf = c("srp_sf_ipm", "srp_sf_ca", "srp_sf_els", "srp_sf_ct"),
    ami = c("ami_es", "ami_sm", "ami_ba"),
    aq_10 = NULL
  )
)

################## RUN ANALYSES AND SAVE OUTPUT ####################
# Read data
data <- read_csv(here("data", "preprocessed", "merged_test_data.csv"), 
                 show_col_types = FALSE)

# Define directory structure
questionnaire_dir <- here("output", "behav", "questionnaire")
analysis_dir <- file.path(questionnaire_dir, "choice_acc_and_bet_mag_by_switch_across_trials")

# Create main output directories for plots and txt
plot_base_dir <- file.path(analysis_dir, "plots")
txt_base_dir <- file.path(analysis_dir, "txt")

# Create txt directory
dir.create(txt_base_dir, recursive = TRUE, showWarnings = FALSE)

# Run accuracy analysis
accuracy_results <- run_model_pipeline(
  data = data,
  params = accuracy_params,
  output_path = file.path(txt_base_dir, "choice_accuracy_by_switch_difference.txt")
)

# Run bet analysis
bet_results <- run_model_pipeline(
  data = data,
  params = bet_params,
  output_path = file.path(txt_base_dir, "bet_magnitude_by_switch_difference.txt")
)

# Save plots for both analyses (chunk 2)
save_analysis_plots(accuracy_results, "choice_accuracy", analysis_dir)
save_analysis_plots(bet_results, "bet_magnitude", analysis_dir)
```

## Supplementary analyses

Bet difference as a function of choice switching on the current trial and group consensus (Fig Supp 2A)

```{r setup, include=FALSE, message=FALSE}
rm(list=ls())

# Source the core pipeline functions
source(here("R", "questionnaire_mixed_models.R"))

################## SPECIFIC PREPROCESSING ###################
preprocess_within_trial_data <- function(data, questionnaire_var, params) {
  # Get subscales for the current questionnaire
  subscales <- params$subscale_mapping[[questionnaire_var]]
  
  # Create base transformations
  base_data <- data %>%
    mutate(
      switch_vs_stay = factor(player.switch_vs_stay),
      consensus_level = case_when(
        player.choice1_with %in% c(0, 1) ~ "4:0",
        player.choice1_with %in% c(0.25, 0.75) ~ "3:1",
        player.choice1_with == 0.5 ~ "2:2"
      ),
      direction = case_when(
        consensus_level == "2:2" ~ "Against group",
        player.choice1_with >= 0.5 ~ "With group",
        TRUE ~ "Against group"
      ),
      consensus_level = factor(consensus_level, levels = c("2:2", "3:1", "4:0")),
      direction = factor(direction, levels = c("Against group", "With group")),
      bet_difference = player.bet2 - player.bet1
    ) %>%
    filter(!(consensus_level == "2:2" & direction == "With group"))
  
  # Aggregate data
  aggregated_data <- base_data %>%
    group_by(participant.id_in_session, consensus_level, direction, switch_vs_stay) %>%
    summarise(
      outcome_value = mean(bet_difference),  # Changed from mean_outcome to outcome_value
      .groups = 'drop'
    )
  
  # Join with questionnaire data and scale
  scaled_data <- aggregated_data %>%
    left_join(
      base_data %>%
        group_by(participant.id_in_session) %>%
        slice(1) %>%
        select(participant.id_in_session, 
               !!questionnaire_var, 
               age,
               gender,
               !!!syms(subscales)),
      by = "participant.id_in_session"
    ) %>%
    mutate(
      scale_name = as.numeric(scale(.data[[questionnaire_var]])),
      age = as.numeric(scale(age)),
      gender = factor(gender)
    )

  # Scale subscales if they exist
  if (!is.null(subscales)) {
    for (subscale in subscales) {
      scaled_data[[subscale]] <- as.numeric(scale(scaled_data[[subscale]]))
    }
  }

  return(scaled_data)
}

################## MODEL FORMULAS ###################
within_trial_model_formulas <- list(
  m1 = list(
    formula = outcome_value ~ consensus_level + direction + switch_vs_stay + scale_name + 
              age + (1|participant.id_in_session),
    description = "Main effects only"
  ),
  m2 = list(
    formula = outcome_value ~ (consensus_level + direction + switch_vs_stay + scale_name)^2 + 
              age + (1|participant.id_in_session),
    description = "Two-way interactions"
  ),
  m3 = list(
    formula = outcome_value ~ consensus_level * direction * switch_vs_stay * scale_name + 
              age + (1|participant.id_in_session),
    description = "Three-way interaction"
  ),
  m4 = list(
    formula = outcome_value ~ consensus_level * direction * switch_vs_stay * scale_name + 
              age + (1 + switch_vs_stay|participant.id_in_session),
    description = "Three-way with random slope for within-trial switching"
  ),
  m5 = list(
    formula = outcome_value ~ consensus_level * direction * switch_vs_stay * scale_name + 
              age + (1 + switch_vs_stay|participant.id_in_session) + (1|gender),
    description = "Full model with gender"
  )
)

# Define parameters for within-trial switch analysis
within_trial_params <- list(
  analysis_type = "within_trial_switch",
  preprocessing_fn = function(data, var, params) {
    preprocess_within_trial_data(data, var, params)
  },
  model_formulas = within_trial_model_formulas,
  questionnaire_vars = c("ssms", "dass", "lsas", "srp_sf", "ami", "aq_10"),
  analysis_name = "Bet Difference by Within-Trial Choice Switch",
  y_label = "Bet difference (Bet 2 - Bet 1)",
  is_percentage = FALSE,
  subscale_mapping = list(
    lsas = c("lsas_p", "lsas_s"),
    dass = c("dass_a", "dass_d", "dass_s"),
    ssms = c("ssms_cd", "ssms_ia"),
    srp_sf = c("srp_sf_ipm", "srp_sf_ca", "srp_sf_els", "srp_sf_ct"),
    ami = c("ami_es", "ami_sm", "ami_ba"),
    aq_10 = NULL
  )
)

################## RUN ANALYSES AND SAVE OUTPUT ###################
# Read data
data <- read_csv(here("data", "preprocessed", "merged_test_data.csv"), 
                 show_col_types = FALSE)

# Define directory structure
questionnaire_dir <- here("output", "behav", "questionnaire")
analysis_dir <- file.path(questionnaire_dir, "bet_diff_by_within_trial_switch")

# Create directories
dir.create(file.path(analysis_dir, "txt"), recursive = TRUE, showWarnings = FALSE)

# Run analysis
within_trial_results <- run_model_pipeline(
  data = data,
  params = within_trial_params,
  output_path = file.path(analysis_dir, "txt", "bet_difference_by_within_trial_switch.txt")
)

# Save plots (chunk 3)
save_analysis_plots(within_trial_results, "within_trial_switch", analysis_dir)
```

## Choice accuracy and bet magnitude by trial position relative to reversal

```{r setup, include=FALSE, message=FALSE}
rm(list=ls())

# Source the core pipeline functions
source(here("R", "questionnaire_mixed_models.R"))

################## SPECIFIC PREPROCESSING ###################
preprocess_reversal_data <- function(data, outcome_type, questionnaire_var, params) {
  
  # Get subscales for the current questionnaire
  subscales <- params$subscale_mapping[[questionnaire_var]]
  
  # Create base transformations with trial position relative to reversal
  base_data <- data %>%
    group_by(participant.id_in_session) %>%
    mutate(
      trial_to_reversal = sapply(seq_along(group.trial_number), function(i) {
        curr_trial <- group.trial_number[i]
        reversal_trials <- which(group.reversal_happened == 1)
        if(length(reversal_trials) == 0) return(NA)
        distances <- abs(curr_trial - reversal_trials)
        min_dist <- min(distances)
        if(min_dist <= 3) {
          return(curr_trial - reversal_trials[which.min(distances)])
        } else {
          return(NA)
        }
      })
    ) %>%
    filter(!is.na(trial_to_reversal)) %>%
    ungroup()

  # Add these two critical checks:
  print("After trial_to_reversal calculation:")
  print("1. Distribution of trials relative to reversal:")
  print(table(base_data$trial_to_reversal))
  
  print("2. Checking if accuracy columns still exist:")
  print("Available columns:")
  print(names(base_data))
  
  trial_summary <- base_data %>%
    group_by(trial_to_reversal) %>%
    summarise(
      n_trials = n(),
      mean_choice1_accuracy = if("player.choice1_accuracy" %in% colnames(base_data)) 
                               mean(player.choice1_accuracy, na.rm = TRUE) * 100 else NA,
      mean_choice2_accuracy = if("player.choice2_accuracy" %in% colnames(base_data)) 
                               mean(player.choice2_accuracy, na.rm = TRUE) * 100 else NA,
      mean_bet1 = if("player.bet1" %in% colnames(base_data)) 
                    mean(player.bet1, na.rm = TRUE) else NA,
      mean_bet2 = if("player.bet2" %in% colnames(base_data)) 
                    mean(player.bet2, na.rm = TRUE) else NA,
      n_participants = n_distinct(participant.id_in_session),
      .groups = 'drop'
    )
  
  print(trial_summary)

  # Process outcome variables based on type
  wide_data <- if(outcome_type == "accuracy") {
    print("\nProcessing accuracy data:")
    temp_data <- base_data %>%
      group_by(participant.id_in_session, trial_to_reversal, gender) %>%
      summarise(
        choice1_accuracy = mean(player.choice1_accuracy, na.rm = TRUE),
        choice2_accuracy = mean(player.choice2_accuracy, na.rm = TRUE),
        .groups = 'drop'
      )
  } else {
    print("\nProcessing bet data:")
    temp_data <- base_data %>%
      group_by(participant.id_in_session, trial_to_reversal, gender) %>%
      summarise(
        choice1_accuracy = mean(player.bet1, na.rm = TRUE),
        choice2_accuracy = mean(player.bet2, na.rm = TRUE),
        .groups = 'drop'
      )
  }

  # Convert to long format
  print("\nConverting to long format:")
  long_data <- wide_data %>%
    pivot_longer(
      cols = c(choice1_accuracy, choice2_accuracy),
      names_to = "choice_type",
      values_to = "outcome_value"
    ) %>%
    mutate(
      choice_type = factor(
        ifelse(choice_type == "choice1_accuracy", "Choice 1", "Choice 2"),
        levels = c("Choice 1", "Choice 2")
      )
    )

  # Join with questionnaire data and scale variables
  scaled_data <- long_data %>%
    left_join(
      base_data %>%
        group_by(participant.id_in_session) %>%
        slice(1) %>%
        select(participant.id_in_session, 
               !!questionnaire_var, 
               age,
               !!!syms(subscales)),
      by = "participant.id_in_session"
    ) %>%
    mutate(
      scale_name = as.numeric(scale(.data[[questionnaire_var]])),
      age = as.numeric(scale(age)),
      gender = factor(gender),
      trial_to_reversal = factor(trial_to_reversal)
    )

  # Print final data check
  print("\nFinal scaled data summary:")
  print(str(scaled_data))
  print(summary(scaled_data))

  # Scale subscales if they exist
  if (!is.null(subscales)) {
    for (subscale in subscales) {
      scaled_data[[subscale]] <- as.numeric(scale(scaled_data[[subscale]]))
    }
  }

  if(params$is_percentage) {
    scaled_data$outcome_value <- scaled_data$outcome_value * 100
  }

  return(scaled_data)
}

################## MODEL FORMULAS ###################
reversal_model_formulas <- list(
  m1 = list(
    formula = outcome_value ~ trial_to_reversal + choice_type + scale_name + 
              age + (1|participant.id_in_session),
    description = "Main effects only"
  ),
  m2 = list(
    formula = outcome_value ~ (trial_to_reversal + choice_type + scale_name)^2 + 
              age + (1|participant.id_in_session),
    description = "Two-way interactions"
  ),
  m3 = list(
    formula = outcome_value ~ trial_to_reversal * choice_type * scale_name + 
              age + (1|participant.id_in_session),
    description = "Three-way interaction"
  )
)

# Define parameters for accuracy analysis
accuracy_params <- list(
  analysis_type = "reversal_learning",
  preprocessing_fn = function(data, var, params) {
    preprocess_reversal_data(data, "accuracy", var, params)
  },
  model_formulas = reversal_model_formulas,
  questionnaire_vars = c("ssms", "dass", "lsas", "srp_sf", "ami", "aq_10"),
  analysis_name = "Choice Accuracy by Trial Position",
  y_label = "Choice accuracy (%)",
  is_percentage = TRUE,
  subscale_mapping = list(
    lsas = c("lsas_p", "lsas_s"),
    dass = c("dass_a", "dass_d", "dass_s"),
    ssms = c("ssms_cd", "ssms_ia"),
    srp_sf = c("srp_sf_ipm", "srp_sf_ca", "srp_sf_els", "srp_sf_ct"),
    ami = c("ami_es", "ami_sm", "ami_ba"),
    aq_10 = NULL
  )
)

# Define parameters for bet analysis
bet_params <- list(
  analysis_type = "reversal_learning",
  preprocessing_fn = function(data, var, params) {
    preprocess_reversal_data(data, "bet", var, params)
  },
  model_formulas = reversal_model_formulas,
  questionnaire_vars = c("ssms", "dass", "lsas", "srp_sf", "ami", "aq_10"),
  analysis_name = "Bet Magnitude by Trial Position",
  y_label = "Bet magnitude",
  is_percentage = FALSE,
  subscale_mapping = list(
    lsas = c("lsas_p", "lsas_s"),
    dass = c("dass_a", "dass_d", "dass_s"),
    ssms = c("ssms_cd", "ssms_ia"),
    srp_sf = c("srp_sf_ipm", "srp_sf_ca", "srp_sf_els", "srp_sf_ct"),
    ami = c("ami_es", "ami_sm", "ami_ba"),
    aq_10 = NULL
  )
)

################## RUN ANALYSES AND SAVE OUTPUT ###################
# Read data
data <- read_csv(here("data", "preprocessed", "merged_test_data.csv"), 
                 show_col_types = FALSE)

# Define directory structure
questionnaire_dir <- here("output", "behav", "questionnaire")
analysis_dir <- file.path(questionnaire_dir, "choice_accuracy_and_bet_magnitude_by_reversal_trial_position")

# Create directories
dir.create(file.path(analysis_dir, "txt"), recursive = TRUE, showWarnings = FALSE)

# Run analyses
accuracy_results <- run_model_pipeline(
  data = data,
  params = accuracy_params,
  output_path = file.path(analysis_dir, "txt", "choice_accuracy_by_trial_position.txt")
)

bet_results <- run_model_pipeline(
  data = data,
  params = bet_params,
  output_path = file.path(analysis_dir, "txt", "bet_magnitude_by_trial_position.txt")
)

# Save plots (for chunk 4)
save_analysis_plots(accuracy_results, "choice_accuracy", analysis_dir)
save_analysis_plots(bet_results, "bet_magnitude", analysis_dir)
```










