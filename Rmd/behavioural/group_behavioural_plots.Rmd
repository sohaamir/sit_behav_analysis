---
title: "behav_plotting"
author: "Aamir Sohail"
date: "2025-01-08"
output: html_document
---

# Description of this script

This script runs the linear mixed-effects models as part of the behavioural analysis for the entire group. It runs and plots the equivalent of Fig 1D-I and Supp Fig 2A-C from Zhang & Glascher.

## Set-up and installation

```{r setup, include=FALSE, message=FALSE, cache=TRUE}
# Install packages only if they are not already installed
required_packages <- c("ggplot2", "tidyverse", "ggpubr", "rstatix", "ez", "lme4", "lmerTest", "car", "emmeans", "here", "MuMIn", "conflicted")
install_if_missing <- required_packages[!required_packages %in% installed.packages()]
if (length(install_if_missing) > 0) {
  install.packages(install_if_missing, quietly = TRUE)
}

# Load libraries
library(ggplot2)
library(tidyverse)
library(ggpubr)
library(rstatix)
library(ez)
library(lme4)
library(car)
library(readr)
library(lmerTest)
library(emmeans)
library(here)
library(MuMIn)
library(conflicted)

conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")
conflicts_prefer(lmerTest::lmer)
```

## Choice accuracy and bet magnitude

Plot average choice accuracy and bet magnitude (Figs 1F and 1G)

```{r, fig.width=4, fig.height=6}
rm(list=ls())

# Read data
data <- read_csv(here("data", "preprocessed", "merged", "sessions", "otree_prolific_merged_filtered_2025-06-03.csv"))

# Create filtered datasets for each analysis
choice1_data <- data %>%
  filter(player.computer_choice_one == 0)

choice2_data <- data %>%
  filter(player.computer_choice_two == 0)

bet1_data <- data %>%
  filter(player.computer_choice_one == 0, 
         player.computer_bet_one == 0)

bet2_data <- data %>%
  filter(player.computer_choice_two == 0, 
         player.computer_bet_two == 0)

# Perform t-tests with filtered datasets
choice_ttest <- t.test(choice2_data$player.choice2_accuracy * 100, 
                      choice1_data$player.choice1_accuracy * 100, 
                      paired = FALSE)

bet_ttest <- t.test(bet2_data$player.bet2, 
                    bet1_data$player.bet1, 
                    paired = FALSE)

# Create summary data for choices
choice_data <- tibble(
  value = c(
    mean(choice1_data$player.choice1_accuracy) * 100,
    mean(choice2_data$player.choice2_accuracy) * 100
  ),
  se = c(
    sd(choice1_data$player.choice1_accuracy) * 100,
    sd(choice2_data$player.choice2_accuracy) * 100
  ) / sqrt(c(nrow(choice1_data), nrow(choice2_data))),
  group = factor(c("Choice 1", "Choice 2"))
)

# Create summary data for bets
bet_data <- tibble(
  value = c(
    mean(bet1_data$player.bet1),
    mean(bet2_data$player.bet2)
  ),
  se = c(
    sd(bet1_data$player.bet1),
    sd(bet2_data$player.bet2)
  ) / sqrt(c(nrow(bet1_data), nrow(bet2_data))),
  group = factor(c("Bet 1", "Bet 2"))
)

# Function to format test results
format_test_results <- function(test_results, data, type) {
  paste0(
    toupper(type), " ANALYSIS\n",
    "==============\n\n",
    "Run on: ", format(Sys.time(), "%Y-%m-%d %H:%M:%S"), "\n\n",
    "T-TEST RESULTS\n",
    "=============\n",
    sprintf("t = %.3f\n", test_results$statistic),
    sprintf("df = %.2f\n", test_results$parameter),
    sprintf("p = %.3e\n", test_results$p.value),
    sprintf("95%% CI [%.3f, %.3f]\n\n", test_results$conf.int[1], test_results$conf.int[2]),
    "DESCRIPTIVE STATISTICS\n",
    "=====================\n",
    sprintf("%s 1: %.2f (SE = %.2f)\n", type, data$value[1], data$se[1]),
    sprintf("%s 2: %.2f (SE = %.2f)", type, data$value[2], data$se[2])
  )
}

# Write results
#writeLines(
#  format_test_results(choice_ttest, choice_data, "Choice"),
#  here("output", "behav", "group", "choice_accuracy_difference.txt")
#)

#writeLines(
#  format_test_results(bet_ttest, bet_data, "Bet"),
#  here("output", "behav", "group", "bet_magnitude_difference.txt")
#)

# Create plots
plots <- list(
  choice = ggplot(choice_data, aes(x = group, y = value)) +
    geom_bar(stat = "identity", width = 0.4, fill = c("#69b3e7", "#1f77b4")) +
    geom_errorbar(aes(ymin = value - se, ymax = value + se), width = 0.07) +
    scale_y_continuous(limits = c(50, 62),  # Increased upper limit to add space at top
                      breaks = c(50, seq(50, 62, by = 5)),  # Kept the same breaks
                      expand = c(0, 0),
                      oob = scales::squish) +
    annotate("text", x = 1.5, y = max(choice_data$value + choice_data$se) + 0.5, size = 5,
             label = sprintf("P = %.4f, d = %.2f", 
                          choice_ttest$p.value, 
                          abs(choice_ttest$statistic) * 2 / sqrt(choice_ttest$parameter))) +
    ylab("Choice accuracy (%)") +
    theme_classic() +
    theme(axis.title.x = element_blank(),
          axis.title.y = element_text(size = 18),
          axis.text = element_text(size = 16)),
    
  bet = ggplot(bet_data, aes(x = group, y = value)) +
    geom_bar(stat = "identity", width = 0.4, fill = c("#98cb85", "#2ca02c")) +
    geom_errorbar(aes(ymin = value - se, ymax = value + se), width = 0.07) +
    scale_y_continuous(limits = c(2.1, 2.45),  # Increased upper limit to add space at top
                      breaks = seq(2.1, 2.4, by = 0.1),  # Kept same breaks
                      expand = c(0, 0),
                      oob = scales::squish) +
    annotate("text", x = 1.5, y = max(bet_data$value + bet_data$se) + 0.03, size = 5,
             label = sprintf("P = %.3e, d = %.2f", 
                          bet_ttest$p.value, 
                          abs(bet_ttest$statistic) * 2 / sqrt(bet_ttest$parameter))) +
    ylab("Bet magnitude") +
    theme_classic() +
    theme(axis.title.x = element_blank(),
          axis.title.y = element_text(size = 18),
          axis.text = element_text(size = 16))
)

# Print plots
print(plots$choice)
print(plots$bet)
```

## Choice switch probability and bet difference by group consensus

Run linear-mixed effect models for choice switch probability and bet difference by group consensus, and then plot the winning model (Figs 1D-1E)
```{r consensus_analysis, fig.width=5, fig.height=8}
rm(list=ls())

source(here("R", "group_behavioural_plots.R"))

################## SPECIFIC PREPROCESSING ###################
process_consensus_data <- function(data, outcome_type) {
  # Initial filtering based on outcome type
  filtered_data <- if(outcome_type == "switch") {
    data %>%
      filter(
        player.computer_choice_one == 0,
        player.computer_choice_two == 0,
        player.player1_choice1_computer == 0,
        player.player2_choice1_computer == 0,
        player.player3_choice1_computer == 0,
        player.player4_choice1_computer == 0
      )
  } else {
    data %>%
      filter(
        player.player1_choice1_computer == 0,
        player.player2_choice1_computer == 0,
        player.player3_choice1_computer == 0,
        player.player4_choice1_computer == 0,
        player.computer_bet_one == 0,
        player.computer_bet_two == 0
      )
  }
  
  # Continue with existing processing
  processed <- if(outcome_type == "switch") {
    filtered_data %>%
      group_by(participant.id_in_session, 
               consensus = player.choice1_with, 
               gender) %>%
      summarise(
        outcome_value = mean(player.switch_vs_stay) * 100,
        .groups = 'drop'
      )
  } else {
    filtered_data %>%
      mutate(bet_difference = player.bet2 - player.bet1) %>%
      group_by(participant.id_in_session,
               consensus = player.choice1_with,
               gender) %>%
      summarise(
        outcome_value = mean(bet_difference),
        .groups = 'drop'
      )
  }
  
  processed %>%
    left_join(
      filtered_data %>%
        group_by(participant.id_in_session) %>%
        slice(1) %>%
        select(participant.id_in_session, age),
      by = "participant.id_in_session"
    ) %>%
    mutate(
      direction = if_else(consensus >= 0.5, "With group", "Against group"),
      consensus_numeric = case_when(
        consensus %in% c(0, 1) ~ 2,
        consensus %in% c(0.25, 0.75) ~ 1,
        consensus == 0.5 ~ 0
      ),
      gender = factor(gender),
      age = scale(age)[,1]
    )
}

################## SPECIFIC MODEL FORMULAS ###################
consensus_model_formulas <- list(
  m1 = outcome_value ~ direction * consensus_numeric + age + 
         (1|participant.id_in_session),
  
  m2 = outcome_value ~ direction * consensus_numeric + age + 
         (1|participant.id_in_session) + (1|gender),
  
  m3 = outcome_value ~ direction * consensus_numeric + age + 
         (1|participant.id_in_session) + (1|gender) + 
         (1|direction:participant.id_in_session),
  
  m4 = outcome_value ~ direction * consensus_numeric + age + 
         (1|participant.id_in_session) + (1|gender) + 
         (1|consensus_numeric:participant.id_in_session),
  
  m5 = outcome_value ~ direction * consensus_numeric + age + 
         (1|participant.id_in_session) + (1|gender) + 
         (1|direction:participant.id_in_session) + 
         (1|consensus_numeric:participant.id_in_session)
)

################## SPECIFIC PLOTTING FUNCTION ###################
create_consensus_plot <- function(data, model_results, anova_results, params) {
  interaction_p <- anova_results["direction:consensus_numeric", "Pr(>Chisq)"]
  
  # Get the effect size from the eta_squared values
  interaction_effect <- params$eta_squared %>%
    filter(Effect == "direction:consensus_numeric") %>%
    pull(partial_eta_sq)
  
  # Create the main plot data as before
  plot_data <- data %>%
    mutate(
      consensus_level = case_when(
        consensus_numeric == 0 ~ "2:2",
        consensus_numeric == 1 ~ "3:1",
        consensus_numeric == 2 ~ "4:0"
      ),
      consensus_level = factor(consensus_level, levels = c("2:2", "3:1", "4:0"))
    ) %>%
    group_by(consensus_level, direction) %>%
    summarise(
      mean_outcome = mean(outcome_value),
      se = sd(outcome_value) / sqrt(n()),
      .groups = 'drop'
    )
  # Get the 2:2 values from "With group"
  with_2_2 <- plot_data %>%
    filter(direction == "With group", consensus_level == "2:2") %>%
    mutate(direction = "Against group")  # Create a copy with "Against group" direction
    
  # Add this to plot_data
  plot_data <- bind_rows(plot_data, with_2_2)
  
  # Calculate data range
  data_min <- min(plot_data$mean_outcome - plot_data$se)
  data_max <- max(plot_data$mean_outcome + plot_data$se)
  data_range <- data_max - data_min
  
  # Determine the appropriate axis settings based on data characteristics
  if(data_range < 1 && abs(data_max) < 1 && abs(data_min) < 1) {
    # Small value range (likely bet difference data)
    # Round to nearest 0.1 with some padding
    y_min <- floor(data_min * 10) / 10 - 0.1
    y_max <- ceiling(data_max * 10) / 10 + 0.1
    
    # Add more padding if range is very narrow
    if(y_max - y_min < 0.5) {
      y_min <- max(-0.2, y_min - 0.1)
      y_max <- min(0.5, y_max + 0.1)
    }
    
    y_breaks <- seq(y_min, y_max, by = 0.1)
    
  } else if(max(plot_data$mean_outcome) > 20) {
    # Likely accuracy data (values in 0-100 range)
    y_min <- floor(data_min / 10) * 10
    y_max <- ceiling(data_max / 10) * 10
    y_breaks <- seq(y_min, y_max, by = 10)
  } else {
    # For other data types, use increments of 1 or 5
    if(data_range < 10) {
      y_min <- floor(data_min)
      y_max <- ceiling(data_max)
      y_breaks <- seq(y_min, y_max, by = 1)
    } else {
      y_min <- floor(data_min / 5) * 5
      y_max <- ceiling(data_max / 5) * 5
      y_breaks <- seq(y_min, y_max, by = 5)
    }
  }
  
  # Create the base plot
  p <- ggplot(plot_data, 
         aes(x = consensus_level, 
             y = mean_outcome, 
             color = direction,
             group = direction)) +
    geom_line(linewidth = 1) +
    geom_point(size = 3) +
    geom_errorbar(aes(ymin = mean_outcome - se, 
                      ymax = mean_outcome + se), 
                  width = 0.2,
                  linewidth = 1) +
    geom_ribbon(aes(ymin = mean_outcome - se, 
                    ymax = mean_outcome + se,
                    fill = direction), 
                alpha = 0.2,
                color = NA) +
    scale_color_manual(values = c("Against group" = "red", "With group" = "blue"),
                      name = NULL) +
    scale_fill_manual(values = c("Against group" = "red", "With group" = "blue"),
                      name = NULL) +
    scale_y_continuous(limits = c(y_min, y_max), breaks = y_breaks) +
    labs(x = "Group consensus",
         y = params$y_label) +
    theme_custom +
    # Position legend in top-left with no box
    theme(
      axis.title = element_text(size = 18),
      axis.text = element_text(size = 14),
      legend.position = c(0.15, 0.95),    # Position in the top-left
      legend.justification = c(0, 1),     # Anchor point at top-left of legend box
      legend.background = element_blank(), # Remove background box
      legend.key = element_blank(),       # Remove box around keys in legend
      legend.text = element_text(size = 14),
      legend.key.size = unit(0.8, "cm"),
      plot.margin = margin(t = 20, r = 20, b = 20, l = 20, unit = "pt")
    )
  
  # Now add the interaction p-value and effect size on two lines with no box
  # Position depends on the plot type
  text_x_pos <- 1  # Just after the "2:2" position
  
  if(y_max > 20) {
    # For the switch probability plot (larger y range)
    text_y_pos <- y_min + (y_max - y_min) * 0.85  # 85% up from bottom
    
    # Add lines of text
    p <- p + 
      # First line: "Interaction:"
      annotate(
        "text",
        x = text_x_pos,
        y = text_y_pos,
        label = "Interaction:",
        hjust = 0,
        fontface = "bold",
        size = 5
      ) +
      # Second line: "P = value, η²ₚ = value"
      annotate(
        "text",
        x = text_x_pos,
        y = text_y_pos - (y_max - y_min) * 0.03,  # Slightly below first line
        label = sprintf("P = %.3e, η²ₚ = %.3f", interaction_p, interaction_effect),
        hjust = 0,
        fontface = "bold",
        size = 5
      )
  } else {
    # For the bet difference plot (smaller y range)
    text_y_pos <- y_min + (y_max - y_min) * 0.75  # 75% up from bottom
    
    # Add lines of text
    p <- p + 
      # First line: "Interaction:"
      annotate(
        "text",
        x = text_x_pos,
        y = text_y_pos,
        label = "Interaction:",
        hjust = 0,
        fontface = "bold",
        size = 5
      ) +
      # Second line: "P = value, η²ₚ = value"
      annotate(
        "text",
        x = text_x_pos,
        y = text_y_pos - (y_max - y_min) * 0.03,  # Slightly below first line
        label = sprintf("P = %.3f, η²ₚ = %.3f", interaction_p, interaction_effect),
        hjust = 0,
        fontface = "bold",
        size = 5
      )
  }
  
  return(p)
}

################## RUN ANALYSES ###################
# Read data
data <- read_csv(here("data", "preprocessed", "merged", "sessions", "otree_prolific_merged_filtered_2025-06-03.csv"), 
                 show_col_types = FALSE)

# Run switch analysis
switch_results <- run_mixed_model_pipeline(
  data = data,
  preprocessing_function = function(x) process_consensus_data(x, "switch"),
  model_formulas = consensus_model_formulas,
  plot_function = create_consensus_plot,
  analysis_name = "Choice Switch by Group Consensus",
  output_path = here("output", "behav", "group", 
                    "choice_switching_by_group_consensus.txt"),
  additional_params = list(
    emmeans_specs = c("direction", "consensus_numeric"),
    y_label = "Choice switch probability (%)",
    y_offset = 5
  )
)

# Run bet difference analysis
bet_results <- run_mixed_model_pipeline(
  data = data,
  preprocessing_function = function(x) process_consensus_data(x, "bet"),
  model_formulas = consensus_model_formulas,
  plot_function = create_consensus_plot,
  analysis_name = "Bet Difference by Group Consensus",
  output_path = here("output", "behav", "group", 
                    "bet_difference_by_group_consensus.txt"),
  additional_params = list(
    emmeans_specs = c("direction", "consensus_numeric"),
    y_label = "Bet difference (Bet 2 - Bet 1)",
    y_offset = 0.5
  )
)
```

## Choice accuracy and bet magnitude and switching across trials/group consensus

Plot Choice 1 accuracy and Bet 1 magnitude as a function of switch difference across trials (Choice 2 - Choice 1) and group consensus (Figs 1H-1I)

```{r, fig.width=7, fig.height=5}
rm(list=ls())

source(here("R", "group_behavioural_plots.R"))

################## SPECIFIC PREPROCESSING ###################
process_switch_accuracy_data <- function(data, outcome_type) {
  # First calculate switches across trials
  processed_data <- data %>%
    group_by(participant.id_in_session) %>%
    arrange(group.trial_number) %>%
    mutate(
      # Calculate switches only for consecutive trials 
      is_consecutive = group.trial_number == lag(group.trial_number) + 1,
      choice_switch_across_trials = case_when(
        is.na(lag(group.trial_number)) ~ NA_real_,  # First trial
        !is_consecutive ~ NA_real_,  # Non-consecutive trials
        TRUE ~ as.numeric(player.chosen_image_one_binary != lag(player.chosen_image_two_binary))
      ),
      # Add flags for computer/group choices
      valid_current_choice = player.computer_choice_one == 0,
      valid_prev_choice = lag(player.computer_choice_two) == 0,
      valid_prev_group = lag(player.player1_choice2_computer) == 0 & 
                        lag(player.player2_choice2_computer) == 0 &
                        lag(player.player3_choice2_computer) == 0 & 
                        lag(player.player4_choice2_computer) == 0,
      # Add bet-specific flags
      valid_current_bet = player.computer_bet_one == 0,
      valid_prev_bet = lag(player.computer_bet_two) == 0
    ) %>%
    ungroup()

  # Apply specific filtering based on outcome type
  filtered_data <- if(outcome_type == "accuracy") {
    processed_data %>%
      filter(
        valid_current_choice,  # Current trial Choice 1 by participant
        valid_prev_choice,     # Previous trial Choice 2 by participant  
        valid_prev_group,      # Previous trial Choice 2 by group
        !is.na(choice_switch_across_trials)  # Valid switch calculation
      )
  } else {
    processed_data %>%
      filter(
        valid_current_choice,  # Current trial Choice 1 by participant
        valid_current_bet,     # Current trial Bet 1 by participant
        valid_prev_choice,     # Previous trial Choice 2 by participant
        valid_prev_bet,        # Previous trial Bet 2 by participant
        valid_prev_group,      # Previous trial Choice 2 by group
        !is.na(choice_switch_across_trials)  # Valid switch calculation
      )
  }

  # Create derived columns
  filtered_data <- filtered_data %>%
    mutate(
      outcome_value = if(outcome_type == "accuracy") {
        player.choice1_accuracy * 100
      } else {
        player.bet1
      },
      switch_difference = choice_switch_across_trials,
      consensus_numeric = case_when(
        player.choice2_with %in% c(0, 1) ~ 2,
        player.choice2_with %in% c(0.25, 0.75) ~ 1,
        player.choice2_with == 0.5 ~ 0
      ),
      consensus_level = case_when(
        consensus_numeric == 2 ~ "4:0",
        consensus_numeric == 1 ~ "3:1",
        consensus_numeric == 0 ~ "2:2"
      ),
      direction = case_when(
        player.choice2_with > 0.5 ~ "With group",
        TRUE ~ "Against group"
      ),
      trial_type = factor(if_else(choice_switch_across_trials == 0, "Stay", "Switch"), 
                         levels = c("Stay", "Switch")),
      consensus_level = factor(consensus_level, levels = c("2:2", "3:1", "4:0")),
      direction = factor(direction, levels = c("Against group", "With group"))
    )

  # Save the intermediate data with only specified columns
  filtered_data %>%
    select(participant.label, participant.id_in_session, group.trial_number, 
           is_consecutive, choice_switch_across_trials, outcome_value, 
           switch_difference, consensus_numeric, consensus_level, direction, 
           trial_type) %>%
    write_csv(here("data", "preprocessed", "merged", "sessions",
               paste0("switch_accuracy_", outcome_type, "_pre_grouping.csv")))

  # Create separate dataframes for With and Against groups using choice 2 consensus
  df_with <- filtered_data %>%
    mutate(direction = "With group") %>%
    filter(player.choice2_with > 0.5)
  
  df_against <- filtered_data %>%
    mutate(direction = "Against group") %>%
    filter(player.choice2_with <= 0.5)
  
  # Combine and prepare final dataset
  combined_data <- bind_rows(df_with, df_against) %>%
    filter(!is.na(choice_switch_across_trials)) %>%
    mutate(
      consensus_numeric = case_when(
        player.choice2_with %in% c(0, 1) ~ 2,
        player.choice2_with %in% c(0.25, 0.75) ~ 1,
        player.choice2_with == 0.5 ~ 0
      ),
      direction = factor(direction),
      gender = factor(gender),
      choice_switch_across_trials = factor(choice_switch_across_trials),
      participant.id_in_session = factor(participant.id_in_session)
    )
  
  return(combined_data)
}

################## SPECIFIC MODEL FORMULAS ###################
get_switch_accuracy_formulas <- function(outcome_var) {
  formula_base <- as.formula(paste(
    outcome_var,
    "~ direction * consensus_numeric * choice_switch_across_trials"
  ))
  
  list(
    m1 = update(formula_base, . ~ . + (1|participant.id_in_session)),
    m2 = update(formula_base, . ~ . + (1|participant.id_in_session) + (1|gender)),
    m3 = update(formula_base, . ~ . + (1|participant.id_in_session) + (1|gender) + 
                (1|direction:participant.id_in_session)),
    m4 = update(formula_base, . ~ . + (1|participant.id_in_session) + (1|gender) + 
                (1|consensus_numeric:participant.id_in_session)),
    m5 = update(formula_base, . ~ . + (1|participant.id_in_session) + (1|gender) + 
                (1|direction:participant.id_in_session) + 
                (1|consensus_numeric:participant.id_in_session))
  )
}

################## SPECIFIC PLOTTING FUNCTION ###################
create_switch_accuracy_plot <- function(data, model_results, anova_results, params) {
  interaction_p <- as.numeric(anova_results[
    "direction:consensus_numeric:choice_switch_across_trials", 
    "Pr(>Chisq)"])
  
  # Get the effect size for the three-way interaction
  interaction_effect <- params$eta_squared %>%
    filter(Effect == "direction:consensus_numeric:choice_switch_across_trials") %>%
    pull(partial_eta_sq)
  
  plot_data <- data %>%
    group_by(consensus_numeric, direction, choice_switch_across_trials) %>%
    summarise(
      value = mean(!!sym(params$outcome_var)),
      se = sd(!!sym(params$outcome_var)) / sqrt(n()),
      .groups = 'drop'
    ) %>%
    mutate(
      consensus_category = case_when(
        consensus_numeric == 2 ~ "4:0",
        consensus_numeric == 1 ~ "3:1",
        consensus_numeric == 0 ~ "2:2"
      ),
      consensus_category = factor(consensus_category, 
                                levels = c("2:2", "3:1", "4:0")),
      # Create a new variable for trial display with the desired order
      trial_display = ifelse(choice_switch_across_trials == 1, 
                           "Switch trials", "Stay trials"),
      # Set the factor levels to control the order (Switch first, then Stay)
      trial_display = factor(trial_display, 
                           levels = c("Switch trials", "Stay trials"))
    )
  
  if(params$is_accuracy) {
    plot_data <- plot_data %>%
      mutate(
        value = value * 100,
        se = se * 100
      )
  }
  
  # Get the 2:2 values from "Against group" for both switch and stay trials
  against_2_2 <- plot_data %>%
    filter(direction == "Against group", consensus_category == "2:2") %>%
    mutate(direction = "With group")
  
  # Add this to plot_data
  plot_data <- bind_rows(plot_data, against_2_2)
  
  p <- ggplot(plot_data, 
         aes(x = consensus_category, 
             y = value, 
             color = direction, 
             group = direction)) +
    # Use the trial_display variable to control facet order
    facet_wrap(~trial_display) +
    geom_line(linewidth = 1) +
    geom_point(size = 3) +
    geom_errorbar(aes(ymin = value - se,
                      ymax = value + se),
                  width = 0.2) +
    geom_ribbon(aes(ymin = value - se,
                    ymax = value + se,
                    fill = direction),
                alpha = 0.2,
                color = NA) +
    scale_color_manual(values = c("Against group" = "red", 
                                 "With group" = "blue")) +
    scale_fill_manual(values = c("Against group" = "red", 
                                "With group" = "blue")) +
    labs(
      x = "Group consensus",
      y = params$y_label,
      color = "Direction",
      fill = "Direction",
      title = "Three-way interaction:",
      subtitle = sprintf("P < %.2f, η²ₚ = %.3f", interaction_p, interaction_effect)
    ) +
    theme_custom +
    # Make axes labels and titles larger
    theme(
      axis.title = element_text(size = 14),
      axis.text = element_text(size = 12),
      strip.text = element_text(size = 14)
    )
  
  # Set y-axis specifically for accuracy plots to 30-80 in increments of 10
  if(params$is_accuracy) {
    p <- p + scale_y_continuous(limits = c(30, 75), 
                              breaks = seq(30, 75, by = 10))
  }
  
  return(p)
}

################## RUN ANALYSES ###################
# Read data
data <- read_csv(here("data", "preprocessed", "merged", "sessions", "otree_prolific_merged_filtered_2025-06-03.csv"), 
                 show_col_types = FALSE)

# Run accuracy analysis
accuracy_results <- run_mixed_model_pipeline(
  data = data,
  preprocessing_function = function(x) process_switch_accuracy_data(x, "accuracy"),
  model_formulas = get_switch_accuracy_formulas("player.choice1_accuracy"),
  plot_function = create_switch_accuracy_plot,
  analysis_name = "Choice Accuracy by Switch and Consensus",
  output_path = here("output", "behav", "group", 
                    "choice_accuracy_by_switch_and_consensus.txt"),
  additional_params = list(
    outcome_var = "player.choice1_accuracy",
    y_label = "Choice 1 accuracy on t + 1 (%)",
    is_accuracy = TRUE,
    emmeans_specs = c("direction", "consensus_numeric", "choice_switch_across_trials")
  )
)

# Run bet magnitude analysis
bet_results <- run_mixed_model_pipeline(
  data = data,
  preprocessing_function = function(x) process_switch_accuracy_data(x, "bet"),
  model_formulas = get_switch_accuracy_formulas("player.bet1"),
  plot_function = create_switch_accuracy_plot,
  analysis_name = "Bet Magnitude by Switch and Consensus",
  output_path = here("output", "behav", "group", 
                    "bet_magnitude_by_switch_and_consensus.txt"),
  additional_params = list(
    outcome_var = "player.bet1",
    y_label = "Bet 1 magnitude on t + 1",
    is_accuracy = FALSE,
    emmeans_specs = c("direction", "consensus_numeric", "choice_switch_across_trials")
  )
)
```

## Supplementary figures 

Bet difference as a function of choice switching on the current trial and group consensus (Fig Supp 2A)
```{r bet_difference_analysis, fig.width=7, fig.height=5}
rm(list=ls())

source(here("R", "group_behavioural_plots.R"))

################## SPECIFIC PREPROCESSING ###################
process_bet_difference_data <- function(data) {
  # First filter out computer trials
  filtered_data <- data %>%
    filter(
      player.computer_bet_one == 0,
      player.computer_bet_two == 0,
      player.computer_choice_one == 0,
      player.computer_choice_two == 0,
      player.player1_choice1_computer == 0,
      player.player2_choice1_computer == 0,
      player.player3_choice1_computer == 0,
      player.player4_choice1_computer == 0
    )

  # Continue with preprocessing
  processed_data <- filtered_data %>%
    {
      nTrials <<- nrow(.)
      .
    } %>%
    mutate(
      bet_difference = player.bet2 - player.bet1,
      direction = if_else(player.choice1_with > 0.5, 
                         "With group", "Against group")
    ) %>%
    filter(!is.na(direction)) %>%
    mutate(
      consensus_numeric = case_when(
        player.choice1_with %in% c(0, 1) ~ 2,
        player.choice1_with %in% c(0.25, 0.75) ~ 1,
        player.choice1_with == 0.5 ~ 0
      ),
      direction = factor(direction),
      gender = factor(gender),
      switch_vs_stay = factor(player.switch_vs_stay),
      participant.id_in_session = factor(participant.id_in_session)
    )
    
  # Save the grouped data
  # write.csv(processed_data, "grouped_consensus_data.csv", row.names = FALSE)
  
  return(processed_data)
}

################## SPECIFIC MODEL FORMULAS ###################
bet_difference_formulas <- list(
  m1 = bet_difference ~ direction * consensus_numeric * switch_vs_stay + 
         (1|participant.id_in_session),
  
  m2 = bet_difference ~ direction * consensus_numeric * switch_vs_stay + 
         (1|participant.id_in_session) + (1|gender),
  
  m3 = bet_difference ~ direction * consensus_numeric * switch_vs_stay + 
         (1|participant.id_in_session) + (1|gender) + 
         (1|direction:participant.id_in_session),
  
  m4 = bet_difference ~ direction * consensus_numeric * switch_vs_stay + 
         (1|participant.id_in_session) + (1|gender) + 
         (1|consensus_numeric:participant.id_in_session),
  
  m5 = bet_difference ~ direction * consensus_numeric * switch_vs_stay + 
         (1|participant.id_in_session) + (1|gender) + 
         (1|direction:participant.id_in_session) + 
         (1|consensus_numeric:participant.id_in_session)
)

################## SPECIFIC PLOTTING FUNCTION ###################
create_bet_difference_plot <- function(data, model_results, anova_results, params) {
  interaction_p <- anova_results[
    "direction:consensus_numeric:switch_vs_stay", 
    "Pr(>Chisq)"]
  
  # Get effect size for the interaction
  interaction_effect <- params$eta_squared %>%
    filter(Effect == "direction:consensus_numeric:switch_vs_stay") %>%
    pull(partial_eta_sq)
  
  plot_data <- data %>%
    group_by(consensus_numeric, direction, switch_vs_stay) %>%
    summarise(
      mean_diff = mean(bet_difference),
      se = sd(bet_difference) / sqrt(n()),
      .groups = 'drop'
    ) %>%
    mutate(
      consensus_category = case_when(
        consensus_numeric == 2 ~ "4:0",
        consensus_numeric == 1 ~ "3:1",
        consensus_numeric == 0 ~ "2:2"
      ),
      consensus_category = factor(consensus_category, 
                                levels = c("2:2", "3:1", "4:0")),
      # Create a new variable for display ordering
      trial_display = ifelse(switch_vs_stay == 1, 
                           '"Switch" trials:\nC2(t) ≠ C1(t)', 
                           '"Stay" trials:\nC2(t) = C1(t)'),
      # Set factor levels to control the order (Switch first, then Stay)
      trial_display = factor(trial_display, 
                           levels = c('"Switch" trials:\nC2(t) ≠ C1(t)', 
                                     '"Stay" trials:\nC2(t) = C1(t)'))
    )
  
  # Get the 2:2 values from "Against group" for both switch and stay trials
  against_2_2 <- plot_data %>%
    filter(direction == "Against group", consensus_category == "2:2") %>%
    mutate(direction = "With group")
  
  # Add this to plot_data to extend With group line to include 2:2
  plot_data <- bind_rows(plot_data, against_2_2)
  
  # Calculate appropriate y-axis bounds based on data
  y_min <- floor(min(plot_data$mean_diff - plot_data$se) * 10) / 10
  y_max <- ceiling(max(plot_data$mean_diff + plot_data$se) * 10) / 10
  
  # Add some padding to ensure data points aren't at the edges
  y_min <- max(y_min - 0.1, -0.3)
  y_max <- min(y_max + 0.1, 0.6)
  
  ggplot(plot_data, 
         aes(x = consensus_category, 
             y = mean_diff, 
             color = direction, 
             group = direction)) +
    facet_wrap(~trial_display) +
    geom_line(linewidth = 1) +
    geom_point(size = 3) +
    geom_errorbar(aes(ymin = mean_diff - se,
                      ymax = mean_diff + se),
                  width = 0.2) +
    geom_ribbon(aes(ymin = mean_diff - se,
                    ymax = mean_diff + se,
                    fill = direction),
                alpha = 0.2,
                color = NA) +
    scale_color_manual(values = c("Against group" = "red", 
                                 "With group" = "blue")) +
    scale_fill_manual(values = c("Against group" = "red", 
                                "With group" = "blue")) +
    scale_y_continuous(limits = c(y_min, y_max), 
                      breaks = seq(y_min, y_max, by = 0.1),
                      labels = function(x) sprintf("%.1f", x)) +
    labs(
      x = "Group consensus",
      y = "Bet difference (Bet 2 - Bet 1)",
      color = "Direction",
      fill = "Direction",
      title = "Direction by Choice:",
      subtitle = sprintf("P = %.2e, η²ₚ = %.3f", interaction_p, interaction_effect)
    ) +
    theme_custom +
    # Make axes text and labels larger
    theme(
      axis.title = element_text(size = 14),
      axis.text = element_text(size = 12),
      strip.text = element_text(size = 12),
      legend.text = element_text(size = 12),
      plot.title = element_text(size = 14),
      plot.subtitle = element_text(size = 12)
    )
}

################## RUN ANALYSIS ###################
# Read data
data <- read_csv(here("data", "preprocessed", "merged", "sessions", "otree_prolific_merged_filtered_2025-06-03.csv"), 
                 show_col_types = FALSE)

# Run analysis
bet_difference_results <- run_mixed_model_pipeline(
  data = data,
  preprocessing_function = process_bet_difference_data,
  model_formulas = bet_difference_formulas,
  plot_function = create_bet_difference_plot,
  analysis_name = "Bet Difference by Choice Switch",
  output_path = here("output", "behav", "group",
                    "bet_difference_by_choice_switch.txt"),
  additional_params = list(
    emmeans_specs = c("direction", "consensus_numeric", "switch_vs_stay")
  )
)
```

## Choice accuracy and bet magnitude relative to reversal (Figs S2-B-C)

Choice accuracy and bet magnitude relative to reversal (plus and minus 3 trials)
```{r reversal_analysis, fig.width=4, fig.height=6}
rm(list=ls())

source(here("R", "group_behavioural_plots.R"))

################## SPECIFIC PREPROCESSING ###################
process_reversal_data <- function(data, outcome_type) {
  # Get reversal trials
  reversal_trials <- data %>% 
    filter(group.reversal_happened == 1) %>%
    select(group.trial_number) %>%
    distinct()
  
  # Define columns based on outcome type
  cols <- if(outcome_type == "accuracy") {
    c(player.choice1_accuracy = "Choice 1", 
      player.choice2_accuracy = "Choice 2")
  } else {
    c(player.bet1 = "Bet 1", 
      player.bet2 = "Bet 2")
  }
  
  # Process data with additional filtering
  processed_data <- data %>%
    group_by(participant.id_in_session) %>%
    mutate(
      trial_to_reversal = map_dbl(group.trial_number, function(x) {
        reversal_trial <- reversal_trials$group.trial_number
        relative_pos <- x - reversal_trial
        if(any(abs(relative_pos) <= 3)) {
          relative_pos[which.min(abs(relative_pos))]
        } else {
          NA
        }
      })
    ) %>%
    filter(!is.na(trial_to_reversal)) %>%
    # Modified filtering based on outcome type
    filter(
      if(outcome_type == "accuracy") {
        player.computer_choice_one == 0 & player.computer_choice_two == 0
      } else {
        player.computer_bet_one == 0 & player.computer_bet_two == 0
      }
    ) %>%
    pivot_longer(
      cols = names(cols),
      names_to = if(outcome_type == "accuracy") "choice_type" else "bet_type",
      values_to = if(outcome_type == "accuracy") "accuracy" else "bet"
    ) %>%
    mutate(
      choice_type = if(outcome_type == "accuracy") 
        factor(choice_type, levels = names(cols), labels = cols) else NULL,
      bet_type = if(outcome_type == "bet")
        factor(bet_type, levels = names(cols), labels = cols) else NULL,
      trial_to_reversal = factor(trial_to_reversal),
      participant.id_in_session = factor(participant.id_in_session),
      gender = factor(gender)
    )
  
  return(processed_data)
}

################## SPECIFIC MODEL FORMULAS ###################
get_reversal_formulas <- function(outcome_type) {
  # Set up formula components
  dv <- if(outcome_type == "accuracy") "accuracy" else "bet"
  iv <- if(outcome_type == "accuracy") "choice_type" else "bet_type"
  
  list(
    m1 = as.formula(paste(dv, "~", iv, "*trial_to_reversal + 
                         (1|participant.id_in_session)")),
    
    m2 = as.formula(paste(dv, "~", iv, "*trial_to_reversal + 
                         (1|participant.id_in_session) + (1|gender)")),
    
    m3 = as.formula(paste(dv, "~", iv, "*trial_to_reversal + 
                         (1|participant.id_in_session) + (1|gender) + (1|", 
                         iv, ":participant.id_in_session)"))
  )
}

################## SPECIFIC PLOTTING FUNCTION ###################
create_reversal_plot <- function(data, model_results, anova_results, params) {
  trial_p <- anova_results["trial_to_reversal", "Pr(>Chisq)"]
  type_col <- params$type_col
  
  # Get R² values from the diagnostics
  r2_marginal <- params$diagnostics$model_fit$r2_marginal
  r2_conditional <- params$diagnostics$model_fit$r2_conditional
  
  plot_data <- data %>%
    group_by(trial_to_reversal, !!sym(type_col)) %>%
    summarise(
      value = mean(!!sym(params$value_col)) * params$scale_factor,
      se = sd(!!sym(params$value_col)) / sqrt(n()) * params$scale_factor,
      .groups = 'drop'
    )
  
  # Calculate data range
  data_min <- min(plot_data$value - plot_data$se)
  data_max <- max(plot_data$value + plot_data$se)
  data_range <- data_max - data_min
  
  # Set appropriate y-axis bounds based on data type
  if(params$is_accuracy) {
    # For accuracy data
    y_min <- max(20, floor(data_min / 10) * 10)
    y_max <- min(100, ceiling(data_max / 10) * 10)
    y_breaks <- seq(y_min, y_max, by = 10)
  } else if(data_min >= 2 && data_max <= 3 && data_range < 0.5) {
    # For bet magnitude data (narrow range between 2-3)
    y_min <- floor(data_min * 10) / 10
    y_max <- ceiling(data_max * 10) / 10
    
    # Ensure we have a reasonable range even with small variations
    if(y_max - y_min < 0.3) {
      y_min <- floor((data_min - 0.1) * 10) / 10
      y_max <- ceiling((data_max + 0.1) * 10) / 10
    }
    
    y_breaks <- seq(y_min, y_max, by = 0.1)
  } else {
    # For other data types
    y_min <- floor(data_min)
    y_max <- ceiling(data_max)
    y_breaks <- seq(y_min, y_max, by = 1)
  }
  
  # Set dodge width for jittering
  dodge_width <- 0.3
  
  ggplot(plot_data, 
         aes(x = trial_to_reversal, 
             y = value, 
             color = !!sym(type_col), 
             group = !!sym(type_col))) +
    # Add jittering with position_dodge
    geom_line(linewidth = 1, position = position_dodge(width = dodge_width)) +
    geom_point(size = 3, position = position_dodge(width = dodge_width)) +
    geom_errorbar(aes(ymin = value - se,
                      ymax = value + se),
                  width = 0.2,
                  position = position_dodge(width = dodge_width)) +
    scale_color_manual(values = params$colors) +
    scale_x_discrete(labels = c("-3", "-2", "-1", "0", "1", "2", "3")) +
    # Use coord_cartesian instead of scale_y_continuous limits
    coord_cartesian(ylim = c(y_min, y_max), expand = FALSE) +
    scale_y_continuous(breaks = y_breaks) +
    labs(
      x = "Trial (relative to reversal)",
      y = params$y_label,
      color = params$legend_title,
      title = "",
      subtitle = sprintf("", 
                       trial_p, r2_marginal, r2_conditional)
    ) +
    theme_custom +
    # Make axes text and labels larger
    theme(
      axis.title = element_text(size = 14),
      axis.text = element_text(size = 12),
      legend.text = element_text(size = 12),
      plot.title = element_text(size = 14),
      plot.subtitle = element_text(size = 12)
    )
}

################## RUN ANALYSES ###################
# Read data
data <- read_csv(here("data", "preprocessed", "merged", "sessions", "otree_prolific_merged_filtered_2025-06-03.csv"), 
                 show_col_types = FALSE)

# Run accuracy analysis
accuracy_results <- run_mixed_model_pipeline(
  data = data,
  preprocessing_function = function(x) process_reversal_data(x, "accuracy"),
  model_formulas = get_reversal_formulas("accuracy"),
  plot_function = create_reversal_plot,
  analysis_name = "Choice Accuracy by Trial Reversal",
  output_path = here("output", "behav", "group",
                    "choice_accuracy_by_trial_reversal.txt"),
  additional_params = list(
    type_col = "choice_type",
    value_col = "accuracy",
    y_label = "Choice accuracy (%)",
    legend_title = "Choice type",
    colors = c("Choice 1" = "lightblue", "Choice 2" = "darkblue"),
    is_accuracy = TRUE,
    scale_factor = 100,
    emmeans_specs = "trial_to_reversal"
  )
)

# Run bet magnitude analysis
bet_results <- run_mixed_model_pipeline(
  data = data,
  preprocessing_function = function(x) process_reversal_data(x, "bet"),
  model_formulas = get_reversal_formulas("bet"),
  plot_function = create_reversal_plot,
  analysis_name = "Bet Magnitude by Trial Reversal",
  output_path = here("output", "behav", "group",
                    "bet_magnitude_by_trial_reversal.txt"),
  additional_params = list(
    type_col = "bet_type",
    value_col = "bet",
    y_label = "Bet magnitude",
    legend_title = "Bet type",
    colors = c("Bet 1" = "#90EE90", "Bet 2" = "#006400"),
    is_accuracy = FALSE,
    scale_factor = 1,
    emmeans_specs = "trial_to_reversal"
  )
)
```
