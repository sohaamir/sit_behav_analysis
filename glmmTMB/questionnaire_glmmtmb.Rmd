---
title: "questionnaires_concise"
author: "Aamir Sohail"
date: "2025-01-17"
output: html_document
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE, cache=TRUE, cache.lazy=FALSE}
# Install packages only if they are not already installed
required_packages <- c("ggplot2", "tidyverse", "ggpubr", "rstatix", "ez", "lme4", 
                       "lmerTest", "car", "emmeans", "MuMIn", "psych", "interactions", 
                       "effects", "here", "lm.beta", "effectsize", "parallel", "gridExtra", 
                       "grid", "conflicted", "glmmTMB", "DHARMa", "performance", "bbmle")
install_if_missing <- required_packages[!required_packages %in% installed.packages()]
if (length(install_if_missing) > 0) {
  install.packages(install_if_missing, quietly = TRUE)
}

# Load libraries
library(ggplot2)
library(tidyverse)
library(ggpubr)
library(rstatix)
library(ez)
library(lme4)
library(car)
library(readr)
library(lmerTest)
library(emmeans)
library(MuMIn)
library(corrplot)
library(reshape2)
library(psych)
library(interactions)
library(effects)
library(here)
library(conflicted)
library(lm.beta)
library(effectsize)
library(parallel)
library(gridExtra)
library(grid)
library(glmmTMB)
library(DHARMa)
library(performance)
library(DHARMa)
library(performance)
library(bbmle)

conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflicts_prefer(lmerTest::lmer)
conflicts_prefer(effectsize::eta_squared)
conflicts_prefer(effectsize::cohens_d)
conflicts_prefer(dplyr::lag)
conflicts_prefer(glmmTMB::glmmTMB)
conflicts_prefer(dplyr::slice)
```

## Plot average choice accuracy and bet magnitude 

```{r choice_accuracy_and_bet_magnitude, include=FALSE, message=FALSE, warning=FALSE}
rm(list=ls())

# Source the core pipeline functions
source(here("R", "questionnaire_behavioural_plots.R"))

################## SPECIFIC PREPROCESSING ###################
prepare_participant_data <- function(data) {
  # Main questionnaires 
  main_scales <- c("ssms", "dass", "lsas", "srp_sf", "ami", "aq_10")
  
  # Get all possible subscales from SUBSCALE_MAPPING
  all_subscales <- unlist(SUBSCALE_MAPPING[names(SUBSCALE_MAPPING) != "aq_10"])
  
  # Create full list of variables we want to keep
  all_vars <- unique(c(main_scales, all_subscales))
  
  # First create summary data
  summary_data <- data %>%
    group_by(participant.id_in_session) %>%
    summarise(
      choice_accuracy_diff = mean(player.choice2_accuracy - player.choice1_accuracy) * 100,
      bet_magnitude_diff = mean(player.bet2 - player.bet1),
      .groups = 'drop'
    )
  
  # Then join with questionnaire data
  questionnaire_data <- data %>%
    group_by(participant.id_in_session) %>%
    slice(1) %>%
    select(participant.id_in_session, all_of(all_vars), age)
  
  # Join and scale
  full_data <- summary_data %>%
    left_join(questionnaire_data, by = "participant.id_in_session") %>%
    mutate(
      across(c(all_of(all_vars), age), scale)
    )
  
  return(full_data)
}

################## ANALYSIS FUNCTIONS ###################
analyze_single_measure <- function(data, questionnaire, measure, outcome_var) {
  model <- lm(paste(outcome_var, "~", questionnaire, "+ age"), data = data)
  model_stats <- summary(model)
  
  cor_test <- cor.test(data[[questionnaire]], data[[outcome_var]])
  
  list(
    p_value = model_stats$coefficients[2,4],
    r_value = cor_test$estimate,
    r_ci_low = cor_test$conf.int[1],
    r_ci_high = cor_test$conf.int[2],
    beta = lm.beta::lm.beta(model)$standardized.coefficients[2],
    resid_norm = shapiro.test(residuals(model))$p.value,
    r2 = model_stats$r.squared,
    f_stat = model_stats$fstatistic["value"],
    df = nrow(data)
  )
}

analyze_questionnaire_effects <- function(questionnaire, data) {
  choice_results <- analyze_single_measure(data, questionnaire, "choice", "choice_accuracy_diff")
  bet_results <- analyze_single_measure(data, questionnaire, "bet", "bet_magnitude_diff")
  
  tibble(
    questionnaire = questionnaire,
    choice_p = choice_results$p_value,
    bet_p = bet_results$p_value,
    choice_r = choice_results$r_value,
    bet_r = bet_results$r_value,
    choice_r_ci_low = choice_results$r_ci_low,
    choice_r_ci_high = choice_results$r_ci_high,
    bet_r_ci_low = bet_results$r_ci_low,
    bet_r_ci_high = bet_results$r_ci_high,
    choice_beta = choice_results$beta,
    bet_beta = bet_results$beta,
    choice_resid_norm = choice_results$resid_norm,
    bet_resid_norm = bet_results$resid_norm,
    choice_r2 = choice_results$r2,
    bet_r2 = bet_results$r2,
    choice_f = choice_results$f_stat,
    choice_df = choice_results$df,
    bet_f = bet_results$f_stat,
    bet_df = bet_results$df
  )
}

################## PLOTTING FUNCTIONS ###################
plot_relationship <- function(questionnaire, measure = "choice", data = participant_data, results_df) {
  measure_vars <- list(
    choice = list(
      y_var = "choice_accuracy_diff",
      y_lab = "Choice accuracy difference (%)",
      fill_color = "#1f77b4",
      prefix = "choice"
    ),
    bet = list(
      y_var = "bet_magnitude_diff",
      y_lab = "Bet magnitude difference",
      fill_color = "#2ca02c",
      prefix = "bet"
    )
  )[[measure]]
  
  vars <- measure_vars
  stats <- results_df[results_df$questionnaire == questionnaire, ]
  
  p <- ggplot(data, aes(x = .data[[questionnaire]], y = .data[[vars$y_var]])) +
    geom_smooth(method = "lm", color = vars$fill_color, fill = "grey80") +
    labs(
      x = questionnaire,
      y = vars$y_lab,
      title = paste("Effect of", questionnaire, "on", measure),
      subtitle = sprintf(
        "r = %.3f [%.3f, %.3f], β = %.3f, p = %.3f\nR² = %.3f, F(%d,%d) = %.2f",
        stats[[paste0(vars$prefix, "_r")]],
        stats[[paste0(vars$prefix, "_r_ci_low")]],
        stats[[paste0(vars$prefix, "_r_ci_high")]],
        stats[[paste0(vars$prefix, "_beta")]],
        stats[[paste0(vars$prefix, "_p")]],
        stats[[paste0(vars$prefix, "_r2")]],
        1,
        stats[[paste0(vars$prefix, "_df")]] - 2,
        stats[[paste0(vars$prefix, "_f")]]
      )
    ) +
    theme_custom

  return(p)
}

################## RUN ANALYSIS ###################
# Read data
data <- read_csv(here("data", "preprocessed", "merged", "sessions", "otree_prolific_merged_filtered_2025-02-21.csv"), 
                show_col_types = FALSE)

# Create filtered datasets for each analysis condition
choice1_data <- data %>%
  filter(player.computer_choice_one == 0)

choice2_data <- data %>%
  filter(player.computer_choice_two == 0)

bet1_data <- data %>%
  filter(player.computer_choice_one == 0, 
         player.computer_bet_one == 0)

bet2_data <- data %>%
  filter(player.computer_choice_two == 0, 
         player.computer_bet_two == 0)

# Preprocess each filtered dataset
participant_data_choice1 <- prepare_participant_data(choice1_data)
participant_data_choice2 <- prepare_participant_data(choice2_data)
participant_data_bet1 <- prepare_participant_data(bet1_data)
participant_data_bet2 <- prepare_participant_data(bet2_data)

# Define directory structure
questionnaire_dir <- here("output", "behav", "questionnaire")
analysis_dir <- file.path(questionnaire_dir, "overall_choice_and_bet_effects")

# Create output directories
plot_base_dir <- file.path(analysis_dir, "plots")
txt_base_dir <- file.path(analysis_dir, "txt")

# Create specific plot subdirectories for choice and bet analyses
plot_choice_dir <- file.path(plot_base_dir, "choice")
plot_bet_dir <- file.path(plot_base_dir, "bet")

# Create subdirectories for main scales and subscales within each analysis type
dir.create(file.path(plot_choice_dir, "continuous"), recursive = TRUE, showWarnings = FALSE)
dir.create(file.path(plot_choice_dir, "subscales"), recursive = TRUE, showWarnings = FALSE)
dir.create(file.path(plot_bet_dir, "continuous"), recursive = TRUE, showWarnings = FALSE)
dir.create(file.path(plot_bet_dir, "subscales"), recursive = TRUE, showWarnings = FALSE)
dir.create(txt_base_dir, recursive = TRUE, showWarnings = FALSE)

# Run main analyses
participant_data <- prepare_participant_data(data)
questionnaires <- c("ssms", "dass", "lsas", "srp_sf", "ami", "aq_10")

# Modify analyze_questionnaire_effects calls to use the appropriate datasets
results <- map_df(questionnaires, function(quest) {
  choice_results <- analyze_single_measure(participant_data_choice2, quest, "choice", "choice_accuracy_diff")
  bet_results <- analyze_single_measure(participant_data_bet2, quest, "bet", "bet_magnitude_diff")
  
  tibble(
    questionnaire = quest,
    choice_p = choice_results$p_value,
    bet_p = bet_results$p_value,
    choice_r = choice_results$r_value,
    bet_r = bet_results$r_value,
    choice_r_ci_low = choice_results$r_ci_low,
    choice_r_ci_high = choice_results$r_ci_high,
    bet_r_ci_low = bet_results$r_ci_low,
    bet_r_ci_high = bet_results$r_ci_high,
    choice_beta = choice_results$beta,
    bet_beta = bet_results$beta,
    choice_resid_norm = choice_results$resid_norm,
    bet_resid_norm = bet_results$resid_norm,
    choice_r2 = choice_results$r2,
    bet_r2 = bet_results$r2,
    choice_f = choice_results$f_stat,
    choice_df = choice_results$df,
    bet_f = bet_results$f_stat,
    bet_df = bet_results$df
  )
})

# Add FDR correction
results <- results %>%
  mutate(
    choice_p_adj = p.adjust(choice_p, method = "fdr"),
    bet_p_adj = p.adjust(bet_p, method = "fdr")
  )

# Run subscale analyses
subscale_results <- map_df(questionnaires, function(quest) {
  if(!is.null(SUBSCALE_MAPPING[[quest]])) {
    map_df(SUBSCALE_MAPPING[[quest]], function(subscale) {
      choice_results <- analyze_single_measure(participant_data_choice2, subscale, "choice", "choice_accuracy_diff")
      bet_results <- analyze_single_measure(participant_data_bet2, subscale, "bet", "bet_magnitude_diff")
      
      tibble(
        questionnaire = subscale,
        choice_p = choice_results$p_value,
        bet_p = bet_results$p_value,
        choice_r = choice_results$r_value,
        bet_r = bet_results$r_value,
        choice_r_ci_low = choice_results$r_ci_low,
        choice_r_ci_high = choice_results$r_ci_high,
        bet_r_ci_low = bet_results$r_ci_low,
        bet_r_ci_high = bet_results$r_ci_high,
        choice_beta = choice_results$beta,
        bet_beta = bet_results$beta,
        choice_resid_norm = choice_results$resid_norm,
        bet_resid_norm = bet_results$resid_norm,
        choice_r2 = choice_results$r2,
        bet_r2 = bet_results$r2,
        choice_f = choice_results$f_stat,
        choice_df = choice_results$df,
        bet_f = bet_results$f_stat,
        bet_df = bet_results$df,
        parent_scale = quest
      )
    })
  }
}) %>%
  filter(!is.na(parent_scale)) %>%
  group_by(parent_scale) %>%
  mutate(
    choice_p_adj = p.adjust(choice_p, method = "fdr"),
    bet_p_adj = p.adjust(bet_p, method = "fdr")
  ) %>%
  ungroup()

# Plot and save main scale relationships
for(quest in questionnaires) {
  # Choice plots
  p_choice <- plot_relationship(quest, "choice", participant_data, results)
  ggsave(
    filename = file.path(plot_choice_dir, "continuous", paste0(quest, ".png")),
    plot = p_choice,
    width = 8,
    height = 6
  )
  
  # Bet plots
  p_bet <- plot_relationship(quest, "bet", participant_data, results)
  ggsave(
    filename = file.path(plot_bet_dir, "continuous", paste0(quest, ".png")),
    plot = p_bet,
    width = 8,
    height = 6
  )
}

# Plot subscale relationships
for(scale in unique(subscale_results$parent_scale)) {
  scale_results <- subscale_results %>% filter(parent_scale == scale)
  
  for(subscale in scale_results$questionnaire) {
    # Choice plots
    p_choice <- plot_relationship(subscale, "choice", participant_data, scale_results)
    ggsave(
      filename = file.path(plot_choice_dir, "subscales", paste0(subscale, ".png")),
      plot = p_choice,
      width = 8,
      height = 6
    )
    
    # Bet plots
    p_bet <- plot_relationship(subscale, "bet", participant_data, scale_results)
    ggsave(
      filename = file.path(plot_bet_dir, "subscales", paste0(subscale, ".png")),
      plot = p_bet,
      width = 8,
      height = 6
    )
  }
}

# Create params list for format_results
analysis_params <- list(
  analysis_type = "overall_effects",
  preprocessing_fn = prepare_participant_data,
  questionnaire_vars = questionnaires,
  analysis_name = "Overall Choice and Bet Effects",
  subscale_mapping = SUBSCALE_MAPPING
)

# Format and save text results
results_text <- format_results_overall(results, subscale_results, analysis_params)
writeLines(results_text, file.path(txt_base_dir, "choice_and_bet_magnitude.txt"))

# Print analysis completion message
cat("\nAnalysis complete.\n")
cat("Results saved in:", analysis_dir, "\n")
```



## Within-trial choice switch probability and bet difference by group consensus and direction

```{r ch_switch_within_trial, include=FALSE, message=FALSE, warning=FALSE}
rm(list=ls())

# Source the core pipeline functions
source(here("R", "questionnaire_behavioural_plots.R"))

################## SPECIFIC PREPROCESSING ###################
preprocess_consensus_data <- function(data, outcome_type, questionnaire_var, group_2_2_in_with = FALSE, params) {
  print(paste("Processing questionnaire:", questionnaire_var))
  print(paste("Initial number of unique participants:", length(unique(data$participant.id_in_session))))
  
  # Initial filtering based on outcome type
  filtered_data <- if(outcome_type == "switch") {
    data %>%
      filter(
        player.computer_choice_one == 0,
        player.computer_choice_two == 0,
        player.player1_choice1_computer == 0,
        player.player2_choice1_computer == 0,
        player.player3_choice1_computer == 0,
        player.player4_choice1_computer == 0
      )
  } else {
    data %>%
      filter(
        player.player1_choice1_computer == 0,
        player.player2_choice1_computer == 0,
        player.player3_choice1_computer == 0,
        player.player4_choice1_computer == 0,
        player.computer_bet_one == 0,
        player.computer_bet_two == 0
      )
  }

  # Get subscales for the current questionnaire
  subscales <- params$subscale_mapping[[questionnaire_var]]
  
  base_data <- filtered_data %>%
    mutate(
      consensus_level = case_when(
        player.choice1_with %in% c(0, 1) ~ "4:0",
        player.choice1_with %in% c(0.25, 0.75) ~ "3:1",
        player.choice1_with == 0.5 ~ "2:2"
      ),
      direction = case_when(
        consensus_level == "2:2" ~ if(group_2_2_in_with) "With group" else "Against group",
        player.choice1_with >= 0.5 ~ "With group",
        TRUE ~ "Against group"
      ),
      consensus_level = factor(consensus_level, levels = c("2:2", "3:1", "4:0")),
      direction = factor(direction, levels = c("Against group", "With group"))
    ) %>%
    filter(!(consensus_level == "2:2" & direction == "With group"))

  # Process outcome variable
  outcome_data <- if(outcome_type == "switch") {
    base_data %>%
      group_by(participant.id_in_session, consensus_level, direction, gender) %>%
      summarise(
        outcome_value = mean(player.switch_vs_stay) * 100,
        .groups = 'drop'
      )
  } else {
    base_data %>%
      mutate(bet_difference = player.bet2 - player.bet1) %>%
      group_by(participant.id_in_session, consensus_level, direction, gender) %>%
      summarise(
        outcome_value = mean(bet_difference),
        .groups = 'drop'
      )
  }

  # Join with questionnaire data 
  joined_data <- outcome_data %>%
    left_join(
      base_data %>%
        group_by(participant.id_in_session) %>%
        slice(1) %>%
        select(participant.id_in_session, 
               !!questionnaire_var, 
               age,
               !!!syms(subscales)),
      by = "participant.id_in_session"
    )
  
  # Scale main variables and subscales consistently
  scaled_data <- joined_data %>%
    mutate(
      scale_name = as.numeric(scale(.data[[questionnaire_var]])),
      age = as.numeric(scale(age)),
      gender = factor(gender)
    )

  # Scale subscales if they exist
  if (!is.null(subscales)) {
    for (subscale in subscales) {
      scaled_data[[subscale]] <- as.numeric(scale(scaled_data[[subscale]]))
    }
  }

  return(scaled_data)
}

################## MODEL FORMULAS ###################
consensus_model_formulas <- list(
  m1 = list(
    formula = outcome_value ~ consensus_level + direction + scale_name + 
              age + (1|participant.id_in_session),
    description = "Main effects only"
  ),
  m2 = list(
    formula = outcome_value ~ (consensus_level + direction + scale_name)^2 + 
              age + (1|participant.id_in_session),
    description = "Two-way interactions"
  ),
  m3 = list(
    formula = outcome_value ~ consensus_level * direction * scale_name + 
              age + (1|participant.id_in_session),
    description = "Three-way interaction"
  ),
  m4 = list(
    formula = outcome_value ~ consensus_level * direction * scale_name + 
              age + (1 + consensus_level|participant.id_in_session),
    description = "Three-way with random slope"
  ),
  m5 = list(
    formula = outcome_value ~ consensus_level * direction * scale_name + 
              age + (1 + consensus_level|participant.id_in_session) + (1|gender),
    description = "Full model with gender"
  )
)

# Define parameters for switch analysis
switch_params <- list(
  analysis_type = "choice_consensus",
  preprocessing_fn = function(data, var, params) {
    preprocess_consensus_data(data, "switch", var, group_2_2_in_with = FALSE, params)  # Explicitly set 2:2 to Against group
  },
  model_formulas = consensus_model_formulas,
  questionnaire_vars = c("ssms", "dass", "lsas", "srp_sf", "ami", "aq_10"),
  analysis_name = "Choice Switch by Group Consensus",
  y_label = "Choice switch probability (%)",
  is_percentage = TRUE,
  subscale_mapping = list(
    lsas = c("lsas_p", "lsas_s"),
    dass = c("dass_a", "dass_d", "dass_s"),
    ssms = c("ssms_cd", "ssms_ia"),
    srp_sf = c("srp_sf_ipm", "srp_sf_ca", "srp_sf_els", "srp_sf_ct"),
    ami = c("ami_es", "ami_sm", "ami_ba"),
    aq_10 = NULL
  )
)

# Define parameters for bet analysis
bet_params <- list(
  analysis_type = "choice_consensus",
  preprocessing_fn = function(data, var, params) {
    preprocess_consensus_data(data, "bet", var, group_2_2_in_with = FALSE, params)  # Explicitly set 2:2 to Against group
  },
  model_formulas = consensus_model_formulas,
  questionnaire_vars = c("ssms", "dass", "lsas", "srp_sf", "ami", "aq_10"),
  analysis_name = "Bet Difference by Group Consensus",
  y_label = "Bet difference (Bet 2 - Bet 1)",
  is_percentage = FALSE,
  subscale_mapping = list(
    lsas = c("lsas_p", "lsas_s"),
    dass = c("dass_a", "dass_d", "dass_s"),
    ssms = c("ssms_cd", "ssms_ia"),
    srp_sf = c("srp_sf_ipm", "srp_sf_ca", "srp_sf_els", "srp_sf_ct"),
    ami = c("ami_es", "ami_sm", "ami_ba"),
    aq_10 = NULL
  )
)

################## RUN ANALYSES AND SAVE OUTPUT ###################
# Read data
data <- read_csv(here("data", "preprocessed", "merged", "sessions", "otree_prolific_merged_filtered_2025-02-21.csv"), 
                 show_col_types = FALSE)

# Define directory structure
questionnaire_dir <- here("output", "behav", "questionnaire")
analysis_dir <- file.path(questionnaire_dir, "ch_switch_and_bet_diff_by_consensus_within_trials")

# Create main output directories for plots and txt
plot_base_dir <- file.path(analysis_dir, "plots")
txt_base_dir <- file.path(analysis_dir, "txt")

# Create txt directory
dir.create(txt_base_dir, recursive = TRUE, showWarnings = FALSE)

# Run switch analysis
switch_results <- run_model_pipeline(
  data = data,
  params = switch_params,
  output_path = file.path(txt_base_dir, "choice_switching_by_group_consensus.txt")
)

# Run bet analysis
bet_results <- run_model_pipeline(
  data = data,
  params = bet_params,
  output_path = file.path(txt_base_dir, "bet_difference_by_group_consensus.txt")
)

# Save plots for both analyses (chunk 1)
save_analysis_plots(switch_results, "choice_switch", analysis_dir)
save_analysis_plots(bet_results, "bet_difference", analysis_dir)
```

## Choice accuracy and bet magnitude as a function of switch difference across trials (Choice 2 - Choice 1), by group consensus and direction

```{r ch_switch_across_trial, include=FALSE, message=FALSE, warning=FALSE}
rm(list=ls())

# Source the core pipeline functions
source(here("R", "questionnaire_behavioural_plots.R"))

################## SPECIFIC PREPROCESSING ###################
preprocess_switch_diff_data <- function(data, outcome_type, questionnaire_var, params) {
  # First calculate switches across trials
  processed_data <- data %>%
    group_by(participant.id_in_session) %>%
    arrange(group.trial_number) %>%
    mutate(
      # Calculate switches only for consecutive trials 
      is_consecutive = group.trial_number == lag(group.trial_number) + 1,
      choice_switch_across_trials = case_when(
        is.na(lag(group.trial_number)) ~ NA_real_,  # First trial
        !is_consecutive ~ NA_real_,  # Non-consecutive trials
        TRUE ~ as.numeric(player.chosen_image_one_binary != lag(player.chosen_image_two_binary))
      ),
      # Add flags for computer/group choices
      valid_current_choice = player.computer_choice_one == 0,
      valid_prev_choice = lag(player.computer_choice_two) == 0,
      valid_prev_group = lag(player.player1_choice2_computer) == 0 & 
                        lag(player.player2_choice2_computer) == 0 &
                        lag(player.player3_choice2_computer) == 0 & 
                        lag(player.player4_choice2_computer) == 0,
      # Add bet-specific flags
      valid_current_bet = player.computer_bet_one == 0,
      valid_prev_bet = lag(player.computer_bet_two) == 0
    ) %>%
    ungroup()
  
  # Apply specific filtering based on outcome type
  filtered_data <- if(outcome_type == "accuracy") {
    processed_data %>%
      filter(
        valid_current_choice,  # Current trial Choice 1 by participant
        valid_prev_choice,     # Previous trial Choice 2 by participant  
        valid_prev_group,      # Previous trial Choice 2 by group
        !is.na(choice_switch_across_trials)  # Valid switch calculation
      )
  } else {
    processed_data %>%
      filter(
        valid_current_choice,  # Current trial Choice 1 by participant
        valid_current_bet,     # Current trial Bet 1 by participant
        valid_prev_choice,     # Previous trial Choice 2 by participant
        valid_prev_bet,        # Previous trial Bet 2 by participant
        valid_prev_group,      # Previous trial Choice 2 by group
        !is.na(choice_switch_across_trials)  # Valid switch calculation
      )
  }

  # Create outcome value based on type
  filtered_data <- filtered_data %>%
    mutate(
      outcome_value = if(outcome_type == "accuracy") {
        player.choice1_accuracy * 100
      } else {
        player.bet1
      },
      switch_difference = choice_switch_across_trials  # Add this explicitly
    )

  # Get subscales for the current questionnaire
  subscales <- params$subscale_mapping[[questionnaire_var]]
  
  # Create final dataset with all transformations
  final_data <- filtered_data %>%
    mutate(
      consensus_numeric = case_when(
        player.choice2_with %in% c(0, 1) ~ 2,
        player.choice2_with %in% c(0.25, 0.75) ~ 1,
        player.choice2_with == 0.5 ~ 0
      ),
      consensus_level = case_when(
        consensus_numeric == 2 ~ "4:0",
        consensus_numeric == 1 ~ "3:1",
        consensus_numeric == 0 ~ "2:2"
      ),
      direction = case_when(
        player.choice2_with > 0.5 ~ "With group",
        TRUE ~ "Against group"
      ),
      trial_type = factor(if_else(choice_switch_across_trials == 0, "Stay", "Switch"), 
                         levels = c("Stay", "Switch")),
      consensus_level = factor(consensus_level, levels = c("2:2", "3:1", "4:0")),
      direction = factor(direction, levels = c("Against group", "With group")),
      gender = factor(gender),
      choice_switch_across_trials = factor(choice_switch_across_trials),
      scale_name = as.numeric(scale(.data[[questionnaire_var]])),
      age = as.numeric(scale(age))
    )

  # Scale subscales if they exist
  if (!is.null(subscales)) {
    for (subscale in subscales) {
      final_data[[subscale]] <- as.numeric(scale(final_data[[subscale]]))
    }
  }
  
    write_csv(final_data, here("data", "preprocessed", "merged", "sessions", paste0("switch_diff_final_", outcome_type, ".csv")))
  
  return(final_data)
}

################## MODEL FORMULAS ###################
switch_diff_model_formulas <- list(
  m1 = list(
    formula = outcome_value ~ consensus_level + direction + switch_difference + scale_name + 
              age + (1|participant.id_in_session),
    description = "Main effects only"
  ),
  m2 = list(
    formula = outcome_value ~ (consensus_level + direction + switch_difference + scale_name)^2 + 
              age + (1|participant.id_in_session),
    description = "Two-way interactions"
  ),
  m3 = list(
    formula = outcome_value ~ consensus_level * direction * switch_difference * scale_name + 
              age + (1|participant.id_in_session),
    description = "Three-way interaction"
  ),
  m4 = list(
    formula = outcome_value ~ consensus_level * direction * switch_difference * scale_name + 
              age + (1 + switch_difference|participant.id_in_session),
    description = "Three-way with random slope for switch difference"
  ),
  m5 = list(
    formula = outcome_value ~ consensus_level * direction * switch_difference * scale_name + 
              age + (1 + switch_difference|participant.id_in_session) + (1|gender),
    description = "Full model with gender"
  )
)

# Define parameters for accuracy analysis
accuracy_params <- list(
  analysis_type = "switch_difference",
  preprocessing_fn = function(data, var, params) {  # Added params parameter
    preprocess_switch_diff_data(data, "accuracy", var, params)  # Pass params through
  },
  model_formulas = switch_diff_model_formulas,
  questionnaire_vars = c("ssms", "dass", "lsas", "srp_sf", "ami", "aq_10"),
  analysis_name = "Choice Accuracy by Switch Difference",
  y_label = "Choice 1 accuracy on t + 1 (%)",
  is_percentage = TRUE,
  subscale_mapping = list(
    lsas = c("lsas_p", "lsas_s"),
    dass = c("dass_a", "dass_d", "dass_s"),
    ssms = c("ssms_cd", "ssms_ia"),
    srp_sf = c("srp_sf_ipm", "srp_sf_ca", "srp_sf_els", "srp_sf_ct"),
    ami = c("ami_es", "ami_sm", "ami_ba"),
    aq_10 = NULL
  )
)

# Define parameters for bet analysis
bet_params <- list(
  analysis_type = "switch_difference",
  preprocessing_fn = function(data, var, params) {  # Added params parameter
    preprocess_switch_diff_data(data, "bet", var, params)  # Pass params through
  },
  model_formulas = switch_diff_model_formulas,
  questionnaire_vars = c("ssms", "dass", "lsas", "srp_sf", "ami", "aq_10"),
  analysis_name = "Bet Magnitude by Switch Difference",
  y_label = "Bet 1 magnitude on t + 1",
  is_percentage = FALSE,
  subscale_mapping = list(
    lsas = c("lsas_p", "lsas_s"),
    dass = c("dass_a", "dass_d", "dass_s"),
    ssms = c("ssms_cd", "ssms_ia"),
    srp_sf = c("srp_sf_ipm", "srp_sf_ca", "srp_sf_els", "srp_sf_ct"),
    ami = c("ami_es", "ami_sm", "ami_ba"),
    aq_10 = NULL
  )
)

################## RUN ANALYSES AND SAVE OUTPUT ####################
# Read data
data <- read_csv(here("data", "preprocessed", "merged", "sessions", "otree_prolific_merged_filtered_2025-02-21.csv"), 
                 show_col_types = FALSE)

# Define directory structure
questionnaire_dir <- here("output", "behav", "questionnaire")
analysis_dir <- file.path(questionnaire_dir, "choice_acc_and_bet_mag_by_switch_across_trials")

# Create main output directories for plots and txt
plot_base_dir <- file.path(analysis_dir, "plots")
txt_base_dir <- file.path(analysis_dir, "txt")

# Create txt directory
dir.create(txt_base_dir, recursive = TRUE, showWarnings = FALSE)

# Run accuracy analysis
accuracy_results <- run_model_pipeline(
  data = data,
  params = accuracy_params,
  output_path = file.path(txt_base_dir, "choice_accuracy_by_switch_difference.txt")
)

# Run bet analysis
bet_results <- run_model_pipeline(
  data = data,
  params = bet_params,
  output_path = file.path(txt_base_dir, "bet_magnitude_by_switch_difference.txt")
)

# Save plots for both analyses (chunk 3)
save_analysis_plots(accuracy_results, "choice_accuracy", analysis_dir)
save_analysis_plots(bet_results, "bet_magnitude", analysis_dir)
```

## Supplementary analyses

Bet difference as a function of choice switching on the current trial and group consensus (Fig Supp 2A)

```{r ch_switch_within_trial_bet_diff, include=FALSE, message=FALSE, warning=FALSE}
rm(list=ls())

# Source the core pipeline functions
source(here("R", "questionnaire_behavioural_plots.R"))

################## SPECIFIC PREPROCESSING ###################
preprocess_within_trial_data <- function(data, questionnaire_var, params) {
  # Get subscales for the current questionnaire
  subscales <- params$subscale_mapping[[questionnaire_var]]
  
  # First filter out computer trials
  base_data <- data %>%
    filter(
      player.computer_bet_one == 0,
      player.computer_bet_two == 0,
      player.computer_choice_one == 0,
      player.computer_choice_two == 0,
      player.player1_choice1_computer == 0,
      player.player2_choice1_computer == 0,
      player.player3_choice1_computer == 0,
      player.player4_choice1_computer == 0
    ) %>%
    # Store number of trials
    {
      nTrials <<- nrow(.)
      .
    } %>%
    # Continue with existing base transformations
    mutate(
      switch_vs_stay = factor(player.switch_vs_stay),
      consensus_level = case_when(
        player.choice1_with %in% c(0, 1) ~ "4:0",
        player.choice1_with %in% c(0.25, 0.75) ~ "3:1",
        player.choice1_with == 0.5 ~ "2:2"
      ),
      direction = case_when(
        consensus_level == "2:2" ~ "Against group",
        player.choice1_with >= 0.5 ~ "With group",
        TRUE ~ "Against group"
      ),
      consensus_level = factor(consensus_level, levels = c("2:2", "3:1", "4:0")),
      direction = factor(direction, levels = c("Against group", "With group")),
      bet_difference = player.bet2 - player.bet1
    ) %>%
    filter(!(consensus_level == "2:2" & direction == "With group"))
  
  # Aggregate data
  aggregated_data <- base_data %>%
    group_by(participant.id_in_session, consensus_level, direction, switch_vs_stay) %>%
    summarise(
      outcome_value = mean(bet_difference),
      .groups = 'drop'
    )
  
  # Join with questionnaire data and scale
  scaled_data <- aggregated_data %>%
    left_join(
      base_data %>%
        group_by(participant.id_in_session) %>%
        slice(1) %>%
        select(participant.id_in_session, 
               !!questionnaire_var, 
               age,
               gender,
               !!!syms(subscales)),
      by = "participant.id_in_session"
    ) %>%
    mutate(
      scale_name = as.numeric(scale(.data[[questionnaire_var]])),
      age = as.numeric(scale(age)),
      gender = factor(gender)
    )
  # Scale subscales if they exist
  if (!is.null(subscales)) {
    for (subscale in subscales) {
      scaled_data[[subscale]] <- as.numeric(scale(scaled_data[[subscale]]))
    }
  }
  return(scaled_data)
}

################## MODEL FORMULAS ###################
within_trial_model_formulas <- list(
  m1 = list(
    formula = outcome_value ~ consensus_level + direction + switch_vs_stay + scale_name + 
              age + (1|participant.id_in_session),
    description = "Main effects only"
  ),
  m2 = list(
    formula = outcome_value ~ (consensus_level + direction + switch_vs_stay + scale_name)^2 + 
              age + (1|participant.id_in_session),
    description = "Two-way interactions"
  ),
  m3 = list(
    formula = outcome_value ~ consensus_level * direction * switch_vs_stay * scale_name + 
              age + (1|participant.id_in_session),
    description = "Three-way interaction"
  ),
  m4 = list(
    formula = outcome_value ~ consensus_level * direction * switch_vs_stay * scale_name + 
              age + (1 + switch_vs_stay|participant.id_in_session),
    description = "Three-way with random slope for within-trial switching"
  ),
  m5 = list(
    formula = outcome_value ~ consensus_level * direction * switch_vs_stay * scale_name + 
              age + (1 + switch_vs_stay|participant.id_in_session) + (1|gender),
    description = "Full model with gender"
  )
)

# Define parameters for within-trial switch analysis
within_trial_params <- list(
  analysis_type = "within_trial_switch",
  preprocessing_fn = function(data, var, params) {
    preprocess_within_trial_data(data, var, params)
  },
  model_formulas = within_trial_model_formulas,
  questionnaire_vars = c("ssms", "dass", "lsas", "srp_sf", "ami", "aq_10"),
  analysis_name = "Bet Difference by Within-Trial Choice Switch",
  y_label = "Bet difference (Bet 2 - Bet 1)",
  is_percentage = FALSE,
  subscale_mapping = list(
    lsas = c("lsas_p", "lsas_s"),
    dass = c("dass_a", "dass_d", "dass_s"),
    ssms = c("ssms_cd", "ssms_ia"),
    srp_sf = c("srp_sf_ipm", "srp_sf_ca", "srp_sf_els", "srp_sf_ct"),
    ami = c("ami_es", "ami_sm", "ami_ba"),
    aq_10 = NULL
  )
)

################## RUN ANALYSES AND SAVE OUTPUT ###################
# Read data
data <- read_csv(here("data", "preprocessed", "merged", "sessions", "otree_prolific_merged_filtered_2025-02-21.csv"), 
                 show_col_types = FALSE)

# Define directory structure
questionnaire_dir <- here("output", "behav", "questionnaire")
analysis_dir <- file.path(questionnaire_dir, "bet_diff_by_within_trial_switch")

# Create directories
dir.create(file.path(analysis_dir, "txt"), recursive = TRUE, showWarnings = FALSE)

# Run analysis
within_trial_results <- run_model_pipeline(
  data = data,
  params = within_trial_params,
  output_path = file.path(analysis_dir, "txt", "bet_difference_by_within_trial_switch.txt")
)

# Save plots (chunk 3)
save_analysis_plots(within_trial_results, "within_trial_switch", analysis_dir)
```

## Questionnaire effects on choice accuracy and bet magnitude around reversals

```{r reversal_trials, include=FALSE, message=FALSE, warning=FALSE}
rm(list=ls())

# Source the core pipeline functions
source(here("R", "questionnaire_behavioural_plots.R"))

# Read data
data <- read_csv(here("data", "preprocessed", "merged", "sessions", "otree_prolific_merged_filtered_2025-02-21.csv"), 
                 show_col_types = FALSE)

################## PRE-PROCESSING ###################
# Get reversal trials
reversal_trials <- data %>% 
  filter(group.reversal_happened == 1) %>%
  select(group.trial_number) %>%
  distinct()

# Process data
reversal_data <- data %>%
  select(
    participant.id_in_session,
    group.trial_number,
    player.choice1_accuracy,
    player.choice2_accuracy,
    player.bet1,
    player.bet2,
    group.reversal_happened,
    # Add computer columns for filtering
    player.computer_choice_one,
    player.computer_choice_two,
    player.computer_bet_one,
    player.computer_bet_two,
    # Main scales and subscales (don't scale them yet)
    ssms, dass, lsas, srp_sf, ami, aq_10,
    lsas_p, lsas_s,
    dass_a, dass_d, dass_s,
    ssms_cd, ssms_ia,
    srp_sf_ipm, srp_sf_ca, srp_sf_els, srp_sf_ct,
    ami_es, ami_sm, ami_ba,
    age, gender
  ) %>%
  # Get trials relative to reversal and check for complete windows
  group_by(participant.id_in_session) %>%
  mutate(
    # For each trial, get its position relative to the closest reversal
    trial_to_reversal = map_dbl(group.trial_number, function(x) {
      reversal_trial <- reversal_trials$group.trial_number
      relative_pos <- x - reversal_trial
      if(any(abs(relative_pos) <= 3)) {
        relative_pos[which.min(abs(relative_pos))]
      } else {
        NA
      }
    }),
    # For each trial within a window, check if all 7 trials exist
    complete_window = map_lgl(group.trial_number, function(x) {
      reversal_trial <- reversal_trials$group.trial_number
      rel_pos <- x - reversal_trial
      if(any(abs(rel_pos) <= 3)) {
        closest_reversal <- reversal_trial[which.min(abs(rel_pos))]
        required_trials <- (closest_reversal - 3):(closest_reversal + 3)
        all(required_trials %in% group.trial_number)
      } else {
        FALSE
      }
    })
  ) %>%
  # Keep only complete windows
  filter(!is.na(trial_to_reversal) & complete_window) %>%
  ungroup() %>%
  mutate(
    trial_to_reversal = factor(trial_to_reversal),
    participant.id_in_session = factor(participant.id_in_session),
    # Scale questionnaire variables and age
    across(c(ssms, dass, lsas, srp_sf, ami, aq_10, age,
            lsas_p, lsas_s,
            dass_a, dass_d, dass_s,
            ssms_cd, ssms_ia,
            srp_sf_ipm, srp_sf_ca, srp_sf_els, srp_sf_ct,
            ami_es, ami_sm, ami_ba), scale)
  )

################## CREATE FILTERED DATASETS ###################
# Create choice-specific dataset
choice_data <- reversal_data %>%
  filter(
    player.computer_choice_one == 0,
    player.computer_choice_two == 0
  )

# Create bet-specific dataset
bet_data <- reversal_data %>%
  filter(
    player.computer_bet_one == 0,
    player.computer_bet_two == 0,
    player.computer_choice_one == 0,
    player.computer_choice_two == 0
  )

# Create directory for output if it doesn't exist
dir.create("processed_data", showWarnings = FALSE)

# Save the main reversal dataset
write.csv(reversal_data, 
          "processed_data/reversal_data_complete.csv", 
          row.names = FALSE)

# Save the choice-specific dataset
write.csv(choice_data, 
          "processed_data/choice_data_filtered.csv", 
          row.names = FALSE)

# Save the bet-specific dataset
write.csv(bet_data, 
          "processed_data/bet_data_filtered.csv", 
          row.names = FALSE)

# Print summary of data
cat("\nReversal Analysis Data Summary:\n")
cat("Number of participants in choice analysis:", n_distinct(choice_data$participant.id_in_session), "\n")
cat("Number of participants in bet analysis:", n_distinct(bet_data$participant.id_in_session), "\n")
cat("Number of complete reversal windows in choice analysis:", n_distinct(choice_data$group.trial_number), "\n")
cat("Number of complete reversal windows in bet analysis:", n_distinct(bet_data$group.trial_number), "\n")

################## DIRECTORY SETUP ###################
# Define questionnaire variables
questionnaire_vars <- c("ssms", "dass", "lsas", "srp_sf", "ami", "aq_10")

# Define directory structure
questionnaire_dir <- here("output", "behav", "questionnaire")
analysis_dir <- file.path(questionnaire_dir, "reversal_analysis")

# Create main output directories for plots and txt
plot_base_dir <- file.path(analysis_dir, "plots")
txt_base_dir <- file.path(analysis_dir, "txt")

# Create specific plot subdirectories
plot_choice_dir <- file.path(plot_base_dir, "median_split", "choice")
plot_bet_dir <- file.path(plot_base_dir, "median_split", "bet")

# Create all directories
dir.create(txt_base_dir, recursive = TRUE, showWarnings = FALSE)
dir.create(plot_choice_dir, recursive = TRUE, showWarnings = FALSE)
dir.create(plot_bet_dir, recursive = TRUE, showWarnings = FALSE)

################## ANALYSIS AND SAVING ###################
# Initialize combined results text
all_choice_results <- ""
all_bet_results <- ""

# Run analysis for each questionnaire
for(var in questionnaire_vars) {
  # Create plots and get test results for choice data
  choice_results <- plot_median_split_reversal(choice_data, var, NULL, NULL, var)
  
  # Create plots and get test results for bet data  
  bet_results <- plot_median_split_reversal(bet_data, var, NULL, NULL, var)
  
  # Save choice plots
  ggsave(
    filename = file.path(plot_choice_dir, paste0(var, "_choice_reversal.png")),
    plot = choice_results$choice_plot,
    width = 5,
    height = 7
  )
  
  # Save bet plots
  ggsave(
    filename = file.path(plot_bet_dir, paste0(var, "_bet_reversal.png")),
    plot = bet_results$bet_plot,
    width = 5,
    height = 7
  )
  
  # Format and append choice results
  formatted_choice_results <- format_results_reversal(choice_results$test_results, 
                                                    choice_results$summary_data, 
                                                    var)
  
  # Format and append bet results
  formatted_bet_results <- format_results_reversal(bet_results$test_results, 
                                                 bet_results$summary_data, 
                                                 var)
  
  all_choice_results <- paste0(all_choice_results, formatted_choice_results$choice_text, "\n\n")
  all_bet_results <- paste0(all_bet_results, formatted_bet_results$bet_text, "\n\n")
  
  # Process subscales if they exist
  if(!is.null(SUBSCALE_MAPPING[[var]])) {
    for(subscale in SUBSCALE_MAPPING[[var]]) {
      # Run subscale analyses on choice data
      choice_subscale_results <- plot_median_split_reversal(choice_data, 
                                                          subscale, 
                                                          NULL, 
                                                          NULL, 
                                                          subscale)
      
      # Run subscale analyses on bet data
      bet_subscale_results <- plot_median_split_reversal(bet_data, 
                                                        subscale, 
                                                        NULL, 
                                                        NULL, 
                                                        subscale)
      
      # Save subscale plots
      ggsave(
        filename = file.path(plot_choice_dir, paste0(subscale, "_choice_reversal.png")),
        plot = choice_subscale_results$choice_plot,
        width = 5,
        height = 7
      )
      
      ggsave(
        filename = file.path(plot_bet_dir, paste0(subscale, "_bet_reversal.png")),
        plot = bet_subscale_results$bet_plot,
        width = 5,
        height = 7
      )
      
      # Format and append subscale results
      formatted_choice_results <- format_results_reversal(choice_subscale_results$test_results,
                                                        choice_subscale_results$summary_data,
                                                        subscale)
      
      formatted_bet_results <- format_results_reversal(bet_subscale_results$test_results,
                                                     bet_subscale_results$summary_data,
                                                     subscale)
      
      all_choice_results <- paste0(all_choice_results, formatted_choice_results$choice_text, "\n\n")
      all_bet_results <- paste0(all_bet_results, formatted_bet_results$bet_text, "\n\n")
    }
  }
}

# Save combined results
writeLines(all_choice_results, 
          file.path(txt_base_dir, "combined_choice_reversal_results.txt"))
writeLines(all_bet_results, 
          file.path(txt_base_dir, "combined_bet_reversal_results.txt"))

# Print analysis completion message
cat("\nAnalysis complete.\n")
cat("Results saved in:", analysis_dir, "\n")
```